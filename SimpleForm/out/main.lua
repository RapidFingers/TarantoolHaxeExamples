-- Generated by Haxe 3.4.0
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local Array = _hx_e()
local EReg = _hx_e()
local chocolate = {}
chocolate.response = {}
chocolate.response.AbstractResponse = _hx_e()
local zephyr = {}
zephyr.View = _hx_e()
local FormView = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
local Server = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local Sys = _hx_e()
local Type = _hx_e()
local http = {}
http.HttpServer = _hx_e()
local tarantool = {}
tarantool.socket = {}
tarantool.socket.TcpSocket = _hx_e()
chocolate.WebSocket = _hx_e()
http.handlers = {}
http.handlers.websocket = {}
http.handlers.websocket.IWSHandler = _hx_e()
chocolate.InternalWebSocketHandle = _hx_e()
chocolate.Chocolate = _hx_e()
chocolate.Request = _hx_e()
chocolate.Route = _hx_e()
chocolate.response._Response = {}
chocolate.response._Response.Response_Impl_ = _hx_e()
chocolate.response.StringResponse = _hx_e()
local haxe = {}
haxe.StackItem = _hx_e()
haxe.CallStack = _hx_e()
haxe.IMap = _hx_e()
haxe._EntryPoint = {}
haxe._EntryPoint.Lock = _hx_e()
haxe._EntryPoint.Mutex = _hx_e()
haxe.EntryPoint = _hx_e()
haxe.Log = _hx_e()
haxe.MainEvent = _hx_e()
haxe.MainLoop = _hx_e()
haxe.Timer = _hx_e()
haxe.Utf8 = _hx_e()
haxe.io = {}
haxe.io.Bytes = _hx_e()
haxe.crypto = {}
haxe.crypto.Base64 = _hx_e()
haxe.crypto.BaseCode = _hx_e()
haxe.crypto.Sha1 = _hx_e()
haxe.ds = {}
haxe.ds.Either = _hx_e()
haxe.ds.IntMap = _hx_e()
haxe.ds.Option = _hx_e()
haxe.ds.StringMap = _hx_e()
haxe.io.BytesBuffer = _hx_e()
haxe.io.Input = _hx_e()
haxe.io.Eof = _hx_e()
haxe.io.Error = _hx_e()
haxe.io.Output = _hx_e()
http.HttpContext = _hx_e()
http.HttpMethod = _hx_e()
http.HttpRequest = _hx_e()
http.HttpResponse = _hx_e()
http._HttpStatus = {}
http._HttpStatus.HttpStatus_Impl_ = _hx_e()
http.HttpVersion = _hx_e()
http.handlers.Handler = _hx_e()
http.handlers.ErrorHandler = _hx_e()
http.handlers.HttpHandler = _hx_e()
http.handlers.StaticHandler = _hx_e()
http.handlers.websocket.FrameType = _hx_e()
http.handlers.websocket.WorkState = _hx_e()
http.handlers.websocket.InternalHandler = _hx_e()
http.handlers.websocket.WebSocketHandler = _hx_e()
local lua = {}
lua.Boot = _hx_e()
lua.UserData = _hx_e()
lua.Thread = _hx_e()
local mime = {}
mime.MimeTypes = _hx_e()
tarantool.fio = {}
tarantool.fio.File = _hx_e()
tarantool.fio.Path = _hx_e()
tarantool.socket.Peer = _hx_e()
tarantool.socket.SocketError = _hx_e()
tarantool.socket.SocketInput = _hx_e()
tarantool.socket.SocketOutput = _hx_e()
local tink = {}
tink._Stringly = {}
tink._Stringly.Stringly_Impl_ = _hx_e()
tink._Url = {}
tink._Url.Url_Impl_ = _hx_e()
tink.core = {}
tink.core._Any = {}
tink.core._Any.Any_Impl_ = _hx_e()
tink.core._Callback = {}
tink.core._Callback.Callback_Impl_ = _hx_e()
tink.core._Callback.LinkObject = _hx_e()
tink.core._Callback.CallbackLink_Impl_ = _hx_e()
tink.core._Callback.SimpleLink = _hx_e()
tink.core._Callback.LinkPair = _hx_e()
tink.core._Callback.ListCell = _hx_e()
tink.core._Callback.CallbackList_Impl_ = _hx_e()
tink.core.TypedError = _hx_e()
tink.core._Error = {}
tink.core._Error.Stack_Impl_ = _hx_e()
tink.core._Future = {}
tink.core._Future.Future_Impl_ = _hx_e()
tink.core._Future.FutureObject = _hx_e()
tink.core._Future.SyncFuture = _hx_e()
tink.core._Future.LazyFuture = _hx_e()
tink.core._Future.SimpleFuture = _hx_e()
tink.core._Future.NestedFuture = _hx_e()
tink.core.FutureTrigger = _hx_e()
tink.core._Lazy = {}
tink.core._Lazy.Lazy_Impl_ = _hx_e()
tink.core._Lazy.LazyObject = _hx_e()
tink.core._Lazy.LazyConst = _hx_e()
tink.core._Lazy.LazyFunc = _hx_e()
tink.core.NamedWith = _hx_e()
tink.core.Noise = _hx_e()
tink.core.OptionTools = _hx_e()
tink.core.OptionIter = _hx_e()
tink.core.Outcome = _hx_e()
tink.core.OutcomeTools = _hx_e()
tink.core._Outcome = {}
tink.core._Outcome.OutcomeMapper_Impl_ = _hx_e()
tink.core._Pair = {}
tink.core._Pair.Pair_Impl_ = _hx_e()
tink.core.MPair = _hx_e()
tink.core._Promise = {}
tink.core._Promise.Promise_Impl_ = _hx_e()
tink.core._Promise.Next_Impl_ = _hx_e()
tink.core._Promise.Recover_Impl_ = _hx_e()
tink.core._Ref = {}
tink.core._Ref.Ref_Impl_ = _hx_e()
tink.core._Signal = {}
tink.core._Signal.Signal_Impl_ = _hx_e()
tink.core.SignalObject = _hx_e()
tink.core._Signal.SimpleSignal = _hx_e()
tink.core.SignalTrigger = _hx_e()
tink.url = {}
tink.url._Auth = {}
tink.url._Auth.Auth_Impl_ = _hx_e()
tink.url._Host = {}
tink.url._Host.Host_Impl_ = _hx_e()
tink.url._Path = {}
tink.url._Path.Path_Impl_ = _hx_e()
tink.url._Portion = {}
tink.url._Portion.Portion_Impl_ = _hx_e()
tink.url._Query = {}
tink.url._Query.Query_Impl_ = _hx_e()
tink.url._Query.QueryStringBuilder_Impl_ = _hx_e()
tink.url._Query.QueryStringParser = _hx_e()
zephyr.HtmlBuilder = _hx_e()
zephyr.tag = {}
zephyr.tag.Tag = _hx_e()
zephyr.tag.TextTag = _hx_e()
zephyr.tag.ATag = _hx_e()
zephyr.tag._FormMethodType = {}
zephyr.tag._FormMethodType.FormMethodType_Impl_ = _hx_e()
zephyr.tag.FormTag = _hx_e()
zephyr.tag.InputTag = _hx_e()
zephyr.tag._InputType = {}
zephyr.tag._InputType.InputType_Impl_ = _hx_e()
zephyr.tag.button = {}
zephyr.tag.button.ButtonTag = _hx_e()
zephyr.tag.link = {}
zephyr.tag.link.LinkTag = _hx_e()
zephyr.tag.script = {}
zephyr.tag.script.ScriptTag = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self,0);
end
Array.__name__ = true
Array.prototype = _hx_a(
  'concat', function(self,a) 
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do 
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      _g:push(i);
      end;
    local ret = _g;
    local _g3 = 0;
    while (_g3 < a.length) do 
      local i1 = a[_g3];
      _g3 = _g3 + 1;
      ret:push(i1);
      end;
    do return ret end
  end,
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'pop', function(self) 
    if (self.length == 0) then 
      do return nil end;
    end;
    local rawlength = _G.rawget(self,"length");
    local ret = _G.rawget(self,rawlength - 1);
    _G.rawset(self,"length",rawlength - 1);
    do return ret end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'shift', function(self) 
    if (self.length == 0) then 
      do return nil end;
    end;
    local ret = self[0];
    local _g1 = 0;
    local _g = self.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[i] = self[i + 1];
      end;
    local tmp = self;
    tmp.length = tmp.length - 1;
    do return ret end
  end,
  'slice', function(self,pos,_end) 
    if ((_end == nil) or (_end > self.length)) then 
      _end = self.length;
    else
      if (_end < 0) then 
        _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
      end;
    end;
    if (pos < 0) then 
      pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
    end;
    if ((pos > _end) or (pos > self.length)) then 
      do return _hx_tab_array({ }, 0) end;
    end;
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = _end;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      end;
    do return ret end
  end,
  'splice', function(self,pos,len) 
    if ((len < 0) or (pos > self.length)) then 
      do return _hx_tab_array({ }, 0) end;
    else
      if (pos < 0) then 
        pos = self.length - (_G.math.fmod(-pos, self.length));
      end;
    end;
    local b = self.length - pos;
    len = (function() 
      local _hx_1
      if (Math.isNaN(len) or Math.isNaN(b)) then 
      _hx_1 = (0/0); else 
      _hx_1 = _G.math.min(len,b); end
      return _hx_1
    end )();
    local ret = _hx_tab_array({ }, 0);
    local _g1 = pos;
    local _g = pos + len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      ret:push(self[i]);
      self[i] = self[i + len];
      end;
    local _g11 = pos + len;
    local _g2 = self.length;
    while (_g11 < _g2) do 
      _g11 = _g11 + 1;
      local i1 = _g11 - 1;
      self[i1] = self[i1 + len];
      end;
    local tmp = self;
    tmp.length = tmp.length - len;
    do return ret end
  end,
  'unshift', function(self,x) 
    local len = self.length;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      self[len - i] = self[(len - i) - 1];
      end;
    self[0] = x;
  end,
  'remove', function(self,x) 
    local _g1 = 0;
    local _g = self.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (self[i] == x) then 
        local _g3 = i;
        local _g2 = self.length - 1;
        while (_g3 < _g2) do 
          _g3 = _g3 + 1;
          local j = _g3 - 1;
          self[j] = self[j + 1];
          end;
        self[self.length - 1] = nil;
        self.length = self.length - 1;
        do return true end;
      end;
      end;
    do return false end
  end,
  'filter', function(self,f) 
    local _g = _hx_tab_array({ }, 0);
    local _g1 = 0;
    local _g2 = self;
    while (_g1 < _g2.length) do 
      local i = _g2[_g1];
      _g1 = _g1 + 1;
      if (f(i)) then 
        _g:push(i);
      end;
      end;
    do return _g end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return cur_length < _gthis.length end;
    end,next=function() 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
  ,'__class__',  Array
)
lua.lib = {}
lua.lib.lrexlib = {}
lua.lib.lrexlib.Rex = _G.require("rex_pcre")

EReg.new = function(r,opt) 
  local self = _hx_new(EReg.prototype)
  EReg.super(self,r,opt)
  return self
end
EReg.super = function(self,r,opt) 
  local ropt = 0;
  local _g1 = 0;
  local _g = opt.length;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    local _g2 = opt:charAt(i);
    local _g21 = _g2;
    if (_g21) == "g" then 
      self.global = true;
    elseif (_g21) == "i" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.CASELESS);
    elseif (_g21) == "m" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.MULTILINE);
    elseif (_g21) == "s" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.DOTALL);
    elseif (_g21) == "u" then 
      ropt = _hx_bit.bor(ropt,EReg.FLAGS.UTF8);else end;
    end;
  if (self.global == nil) then 
    self.global = false;
  end;
  self.r = lua.lib.lrexlib.Rex.new(r,ropt);
end
EReg.__name__ = true
EReg.prototype = _hx_a(
  'match', function(self,s) 
    if (s == nil) then 
      do return false end;
    end;
    self.m = _hx_table.pack(self.r:exec(s));
    self.s = s;
    do return self.m[1] ~= nil end
  end,
  'matched', function(self,n) 
    if ((self.m[1] == nil) or (n < 0)) then 
      _G.error("EReg::matched",0);
    else
      if (n == 0) then 
        local k = _G.string.sub(self.s,self.m[1],self.m[2]);
        do return k end;
      else
        if (lua.Boot.__instanceof(self.m[3],_G.table)) then 
          local mn = 2 * (n - 1);
          if (lua.Boot.__instanceof(self.m[3][mn + 1],Bool)) then 
            do return nil end;
          end;
          do return _G.string.sub(self.s,self.m[3][mn + 1],self.m[3][mn + 2]) end;
        else
          _G.error("EReg:matched",0);
        end;
      end;
    end;
  end
  ,'__class__',  EReg
)

chocolate.response.AbstractResponse.new = {}
chocolate.response.AbstractResponse.__name__ = true
chocolate.response.AbstractResponse.prototype = _hx_a(
  'toString', function(self) 
    do return nil end
  end
  ,'__class__',  chocolate.response.AbstractResponse
)

zephyr.View.new = function() 
  local self = _hx_new(zephyr.View.prototype)
  zephyr.View.super(self)
  return self
end
zephyr.View.super = function(self) 
end
zephyr.View.__name__ = true
zephyr.View.prototype = _hx_a(
  'render', function(self) 
    do return nil end
  end,
  'toString', function(self) 
    local tag = self:render();
    if (tag ~= nil) then 
      do return "<!DOCTYPE html>" .. tag:toString() end;
    end;
    do return "" end
  end
  ,'__class__',  zephyr.View
)
zephyr.View.__super__ = chocolate.response.AbstractResponse
setmetatable(zephyr.View.prototype,{__index=chocolate.response.AbstractResponse.prototype})

FormView.new = function() 
  local self = _hx_new(FormView.prototype)
  FormView.super(self)
  return self
end
FormView.super = function(self) 
  zephyr.View.super(self);
end
FormView.__name__ = true
FormView.prototype = _hx_a(
  'fieldWrap', function(self,text) 
    local tmp = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp1 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text=text}),_hx_tab_array({[0]=tmp }, 1));
    local tmp2 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    do return zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp1, tmp2 }, 2)) end
  end,
  'singUpTab', function(self) 
    local tmp = zephyr.HtmlBuilder.h1(_hx_o({__fields__={text=true},text="Sign Up for Free"}));
    local tmp1 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp2 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="First Name"}),_hx_tab_array({[0]=tmp1 }, 1));
    local tmp3 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp4 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp2, tmp3 }, 2));
    local tmp5 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp6 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Last Name"}),_hx_tab_array({[0]=tmp5 }, 1));
    local tmp7 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp8 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp6, tmp7 }, 2));
    local tmp9 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="top-row"}),_hx_tab_array({[0]=tmp4, tmp8 }, 2));
    local tmp10 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp11 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Email Address"}),_hx_tab_array({[0]=tmp10 }, 1));
    local tmp12 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp13 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp11, tmp12 }, 2));
    local tmp14 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp15 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Set A Password"}),_hx_tab_array({[0]=tmp14 }, 1));
    local tmp16 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp17 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp15, tmp16 }, 2));
    local tmp18 = zephyr.HtmlBuilder.button(_hx_o({__fields__={css=true,text=true,type=true},css="button button-block",text="Get Started",type="submit"}));
    local tmp19 = zephyr.HtmlBuilder.form(_hx_o({__fields__={action=true,method=true},action="/signup",method="post"}),_hx_tab_array({[0]=tmp9, tmp13, tmp17, tmp18 }, 4));
    do return zephyr.HtmlBuilder.div(_hx_o({__fields__={id=true,style=true},id="signup",style="display : block;"}),_hx_tab_array({[0]=tmp, tmp19 }, 2)) end
  end,
  'singInTab', function(self) 
    local tmp = zephyr.HtmlBuilder.h1(_hx_o({__fields__={text=true},text="Welcome Back!"}));
    local tmp1 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp2 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Email Address"}),_hx_tab_array({[0]=tmp1 }, 1));
    local tmp3 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp4 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp2, tmp3 }, 2));
    local tmp5 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp6 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Password"}),_hx_tab_array({[0]=tmp5 }, 1));
    local tmp7 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp8 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp6, tmp7 }, 2));
    local tmp9 = zephyr.HtmlBuilder.a(_hx_o({__fields__={text=true,href=true},text="Forgot Password?",href="#"}));
    local tmp10 = zephyr.HtmlBuilder.p(_hx_o({__fields__={css=true},css="forgot"}),_hx_tab_array({[0]=tmp9 }, 1));
    local tmp11 = zephyr.HtmlBuilder.button(_hx_o({__fields__={css=true,text=true,type=true},css="button button-block",text="Get Started",type="submit"}));
    local tmp12 = zephyr.HtmlBuilder.form(_hx_o({__fields__={action=true,method=true},action="/signin",method="post"}),_hx_tab_array({[0]=tmp4, tmp8, tmp10, tmp11 }, 4));
    do return zephyr.HtmlBuilder.div(_hx_o({__fields__={id=true,style=true},id="signin",style="display : none;"}),_hx_tab_array({[0]=tmp, tmp12 }, 2)) end
  end,
  'render', function(self) 
    local tmp = zephyr.HtmlBuilder.head(nil,_hx_tab_array({[0]=zephyr.HtmlBuilder.link(_hx_o({__fields__={rel=true,href=true},rel="stylesheet",href="http://fonts.googleapis.com/css?family=Titillium+Web:400,300,600"})), zephyr.HtmlBuilder.link(_hx_o({__fields__={rel=true,href=true},rel="stylesheet",href="https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css"})), zephyr.HtmlBuilder.link(_hx_o({__fields__={rel=true,href=true},rel="stylesheet",href="./media/css/style.css"})) }, 3));
    local tmp1 = zephyr.HtmlBuilder.a(_hx_o({__fields__={href=true,text=true},href="#signup",text="Sign Up"}));
    local tmp2 = zephyr.HtmlBuilder.li(_hx_o({__fields__={css=true},css="tab active"}),_hx_tab_array({[0]=tmp1 }, 1));
    local tmp3 = zephyr.HtmlBuilder.a(_hx_o({__fields__={href=true,text=true},href="#signin",text="Log In"}));
    local tmp4 = zephyr.HtmlBuilder.li(_hx_o({__fields__={css=true},css="tab"}),_hx_tab_array({[0]=tmp3 }, 1));
    local tmp5 = zephyr.HtmlBuilder.ul(_hx_o({__fields__={css=true},css="tab-group"}),_hx_tab_array({[0]=tmp2, tmp4 }, 2));
    local tmp6 = zephyr.HtmlBuilder.h1(_hx_o({__fields__={text=true},text="Sign Up for Free"}));
    local tmp7 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp8 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="First Name"}),_hx_tab_array({[0]=tmp7 }, 1));
    local tmp9 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp10 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp8, tmp9 }, 2));
    local tmp11 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp12 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Last Name"}),_hx_tab_array({[0]=tmp11 }, 1));
    local tmp13 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp14 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp12, tmp13 }, 2));
    local tmp15 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="top-row"}),_hx_tab_array({[0]=tmp10, tmp14 }, 2));
    local tmp16 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp17 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Email Address"}),_hx_tab_array({[0]=tmp16 }, 1));
    local tmp18 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp19 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp17, tmp18 }, 2));
    local tmp20 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp21 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Set A Password"}),_hx_tab_array({[0]=tmp20 }, 1));
    local tmp22 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp23 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp21, tmp22 }, 2));
    local tmp24 = zephyr.HtmlBuilder.button(_hx_o({__fields__={css=true,text=true,type=true},css="button button-block",text="Get Started",type="submit"}));
    local tmp25 = zephyr.HtmlBuilder.form(_hx_o({__fields__={action=true,method=true},action="/signup",method="post"}),_hx_tab_array({[0]=tmp15, tmp19, tmp23, tmp24 }, 4));
    local tmp26 = zephyr.HtmlBuilder.div(_hx_o({__fields__={id=true,style=true},id="signup",style="display : block;"}),_hx_tab_array({[0]=tmp6, tmp25 }, 2));
    local tmp27 = zephyr.HtmlBuilder.h1(_hx_o({__fields__={text=true},text="Welcome Back!"}));
    local tmp28 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp29 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Email Address"}),_hx_tab_array({[0]=tmp28 }, 1));
    local tmp30 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp31 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp29, tmp30 }, 2));
    local tmp32 = zephyr.HtmlBuilder.span(_hx_o({__fields__={css=true,text=true},css="req",text="*"}));
    local tmp33 = zephyr.HtmlBuilder.label(_hx_o({__fields__={text=true},text="Password"}),_hx_tab_array({[0]=tmp32 }, 1));
    local tmp34 = zephyr.HtmlBuilder.input(_hx_o({__fields__={type=true,required=true,autocomplete=true},type="text",required=true,autocomplete=true}));
    local tmp35 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="field-wrap"}),_hx_tab_array({[0]=tmp33, tmp34 }, 2));
    local tmp36 = zephyr.HtmlBuilder.a(_hx_o({__fields__={text=true,href=true},text="Forgot Password?",href="#"}));
    local tmp37 = zephyr.HtmlBuilder.p(_hx_o({__fields__={css=true},css="forgot"}),_hx_tab_array({[0]=tmp36 }, 1));
    local tmp38 = zephyr.HtmlBuilder.button(_hx_o({__fields__={css=true,text=true,type=true},css="button button-block",text="Get Started",type="submit"}));
    local tmp39 = zephyr.HtmlBuilder.form(_hx_o({__fields__={action=true,method=true},action="/signin",method="post"}),_hx_tab_array({[0]=tmp31, tmp35, tmp37, tmp38 }, 4));
    local tmp40 = zephyr.HtmlBuilder.div(_hx_o({__fields__={id=true,style=true},id="signin",style="display : none;"}),_hx_tab_array({[0]=tmp27, tmp39 }, 2));
    local tmp41 = zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="tab-content"}),_hx_tab_array({[0]=tmp26, tmp40 }, 2));
    do return zephyr.HtmlBuilder.html(nil,_hx_tab_array({[0]=tmp, zephyr.HtmlBuilder.body(nil,_hx_tab_array({[0]=zephyr.HtmlBuilder.div(_hx_o({__fields__={css=true},css="form"}),_hx_tab_array({[0]=tmp5, tmp41 }, 2)), zephyr.HtmlBuilder.script(_hx_o({__fields__={type=true,src=true},type="text/javascript",src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"})), zephyr.HtmlBuilder.script(_hx_o({__fields__={type=true,src=true},type="text/javascript",src="./media/js/index.js"})) }, 3)) }, 2)) end
  end
  ,'__class__',  FormView
)
FormView.__super__ = zephyr.View
setmetatable(FormView.prototype,{__index=zephyr.View.prototype})

Math.new = {}
Math.__name__ = true
Math.isNaN = function(f) 
  do return f ~= f end;
end

Reflect.new = {}
Reflect.__name__ = true
Reflect.field = function(o,field) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      do return o[field] end;
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    local e = _hx_1
    do return nil end;
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
Reflect.fields = function(o) 
  local _g = _hx_tab_array({ }, 0);
  local f = lua.Boot.fieldIterator(o);
  while (f:hasNext()) do 
    local f1 = f:next();
    _g:push(f1);
    end;
  do return _g end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.copy = function(o) 
  local o2 = _hx_e();
  local _g = 0;
  local _g1 = Reflect.fields(o);
  while (_g < _g1.length) do 
    local f = _g1[_g];
    _g = _g + 1;
    o2[f] = Reflect.field(o,f);
    end;
  do return o2 end;
end

Server.new = {}
Server.__name__ = true
Server.main = function() 
  chocolate.Chocolate.App:get("/",function(r) 
    do return chocolate.response._Response.Response_Impl_._new(FormView.new()) end;
  end);
  chocolate.Chocolate.App:post("/signup",function(r1) 
    do return chocolate.response._Response.Response_Impl_._new(chocolate.response.StringResponse.new("Registration success.")) end;
  end);
  chocolate.Chocolate.App:post("/signin",function(r2) 
    do return chocolate.response._Response.Response_Impl_._new(chocolate.response.StringResponse.new("Wrong login")) end;
  end);
  chocolate.Chocolate.App:listen(_hx_o({__fields__={Port=true,StaticDir=true},Port=65201,StaticDir="./media"}));
end

String.new = {}
String.__name__ = true
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'toLowerCase', function(self) 
    do return _G.string.lower(self) end
  end,
  'indexOf', function(self,str,startIndex) 
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = _G.string.find(self,str,startIndex,true);
    if ((r ~= nil) and (r > 0)) then 
      do return r - 1 end;
    else
      do return -1 end;
    end;
  end,
  'lastIndexOf', function(self,str,startIndex) 
    local i = 0;
    local ret = -1;
    if (startIndex == nil) then 
      startIndex = self.length;
    end;
    while (true) do 
      local p = self:indexOf(str,ret + 1);
      if ((p == -1) or (p > startIndex)) then 
        do return ret end;
      end;
      ret = p;
      end;
  end,
  'split', function(self,delimiter) 
    local idx = 1;
    local ret = _hx_tab_array({ }, 0);
    local delim_offset = (function() 
      local _hx_1
      if (delimiter.length > 0) then 
      _hx_1 = delimiter.length; else 
      _hx_1 = 1; end
      return _hx_1
    end )();
    while (idx ~= nil) do 
      local newidx = 0;
      if (delimiter.length > 0) then 
        newidx = _G.string.find(self,delimiter,idx,true);
      else
        if (idx >= self.length) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        local match = _G.string.sub(self,idx,newidx - 1);
        ret:push(match);
        idx = newidx + delimiter.length;
      else
        ret:push(_G.string.sub(self,idx,_G.string.len(self)));
        idx = nil;
      end;
      end;
    do return ret end
  end,
  'toString', function(self) 
    do return self end
  end,
  'substring', function(self,startIndex,endIndex) 
    if (endIndex == nil) then 
      endIndex = self.length;
    end;
    if (endIndex < 0) then 
      endIndex = 0;
    end;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
    if (endIndex < startIndex) then 
      do return _G.string.sub(self,endIndex + 1,startIndex) end;
    else
      do return _G.string.sub(self,startIndex + 1,endIndex) end;
    end;
  end,
  'charAt', function(self,index) 
    do return _G.string.sub(self,index + 1,index + 1) end
  end,
  'charCodeAt', function(self,index) 
    do return _G.string.byte(self,index + 1) end
  end,
  'substr', function(self,pos,len) 
    if ((len == nil) or (len > (pos + self.length))) then 
      len = self.length;
    else
      if (len < 0) then 
        len = self.length + len;
      end;
    end;
    if (pos < 0) then 
      pos = self.length + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(self,pos + 1,pos + len) end
  end
  ,'__class__',  String
)

Std.new = {}
Std.__name__ = true
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.int = function(x) 
  do return _hx_bit_clamp(x) end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local hexMatch = _G.string.match(x,"^ *[%-+]*0[xX][%da-FA-F]*");
  if (hexMatch ~= nil) then 
    do return _G.tonumber(hexMatch:substr(2),16) end;
  else
    local intMatch = _G.string.match(x,"^ *[%-+]?%d*");
    if (intMatch ~= nil) then 
      do return _G.tonumber(intMatch) end;
    else
      do return nil end;
    end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x,"^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  x = x:substr(digitMatch.length);
  local decimalMatch = _G.string.match(x,"^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  x = x:substr(decimalMatch.length);
  local eMatch = _G.string.match(x,"^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(digitMatch .. decimalMatch .. eMatch);
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = _hx_e();
  self.length = 0;
end
StringBuf.__name__ = true
StringBuf.prototype = _hx_a(
  
  '__class__',  StringBuf
)

StringTools.new = {}
StringTools.__name__ = true
StringTools.urlEncode = function(s) 
  s = _G.string.gsub(s,"\n","\r\n");
  s = _G.string.gsub(s,"([^%w %-%_%.%~])",function(c) 
    do return _G.string.format("%%%02X",_G.string.byte(c) .. "") end;
  end);
  s = _G.string.gsub(s," ","+");
  do return s end;
end
StringTools.urlDecode = function(s) 
  s = _G.string.gsub(s,"+"," ");
  s = _G.string.gsub(s,"%%(%x%x)",function(h) 
    do return _G.string.char(_G.tonumber(h,16)) end;
  end);
  s = _G.string.gsub(s,"\r\n","\n");
  do return s end;
end
StringTools.startsWith = function(s,start) 
  if (s.length >= start.length) then 
    do return s:substr(0,start.length) == start end;
  else
    do return false end;
  end;
end
StringTools.endsWith = function(s,_end) 
  local elen = _end.length;
  local slen = s.length;
  if (slen >= elen) then 
    do return s:substr(slen - elen,elen) == _end end;
  else
    do return false end;
  end;
end
StringTools.isSpace = function(s,pos) 
  if (((s.length == 0) or (pos < 0)) or (pos >= s.length)) then 
    do return false end;
  end;
  local c = s:charCodeAt(pos);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = s.length;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s,r)) do 
    r = r + 1;
    end;
  if (r > 0) then 
    do return s:substr(r,l - r) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = s.length;
  local r = 0;
  while ((r < l) and StringTools.isSpace(s,(l - r) - 1)) do 
    r = r + 1;
    end;
  if (r > 0) then 
    do return s:substr(0,l - r) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end
StringTools.replace = function(s,sub,by) 
  do return s:split(sub):join(by) end;
end
StringTools.hex = function(n,digits) 
  local s = "";
  local hexChars = "0123456789ABCDEF";
  while (true) do 
    s = hexChars:charAt(_hx_bit.band(n,15)) .. s;
    n = _hx_bit.rshift(n,4);
    if (not (n > 0)) then 
      break;
    end;
    end;
  if (digits ~= nil) then 
    while (s.length < digits) do 
      s = "0" .. s;
      end;
  end;
  do return s end;
end

Sys.new = {}
Sys.__name__ = true
Sys.time = function() 
  do return lua.lib.luasocket.Socket.gettime() end;
end

Type.new = {}
Type.__name__ = true
Type.createEnum = function(e,constr,params) 
  local f = Reflect.field(e,constr);
  if (f == nil) then 
    _G.error("No such constructor " .. constr,0);
  end;
  if (Reflect.isFunction(f)) then 
    if (params == nil) then 
      _G.error("Constructor " .. constr .. " need parameters",0);
    end;
    local func = f;
    if ((params == nil) or (params.length == 0)) then 
      do return func(nil) end;
    else
      local self_arg = false;
      local new_args = ({});
      local _g1 = 0;
      local _g = params.length;
      while (_g1 < _g) do 
        _g1 = _g1 + 1;
        local i = _g1 - 1;
        new_args[i + 1] = params[i];
        end;
      if (self_arg) then 
        do return func(nil,_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
      else
        do return func(_hx_table.unpack(new_args,1,_hx_table.maxn(new_args))) end;
      end;
    end;
  end;
  if ((params ~= nil) and (params.length ~= 0)) then 
    _G.error("Constructor " .. constr .. " does not need parameters",0);
  end;
  do return f end;
end

http.HttpServer.new = function() 
  local self = _hx_new(http.HttpServer.prototype)
  http.HttpServer.super(self)
  return self
end
http.HttpServer.super = function(self) 
  self._socket = tarantool.socket.TcpSocket.new();
end
http.HttpServer.__name__ = true
http.HttpServer.prototype = _hx_a(
  'processClient', function(self,channel) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        while (true) do 
          local request = http.HttpRequest.new(channel);
          local response = http.HttpResponse.new(channel);
          local context = http.HttpContext.new(request,response);
          self._firstHandler:process(context);
          end;
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,tarantool.socket.SocketError) ) then 
        local e = _hx_1
      else
      local e1 = _hx_1
      haxe.Log.trace(e1,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="HttpServer.hx",lineNumber=66,className="http.HttpServer",methodName="processClient"}));
      channel.output:close();
       end 
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'addHandler', function(self,handler) 
    if (self._firstHandler == nil) then 
      self._firstHandler = handler;
      self._lastHandler = handler;
    end;
    self._lastHandler.Next = handler;
    self._lastHandler = handler;
  end,
  'bind', function(self,host,port) 
    local _gthis = self;
    if (self._firstHandler == nil) then 
      _G.error("No handlers",0);
    end;
    self._socket:bind(host,port,function(c) 
      _gthis:processClient(c);
    end);
  end
  ,'__class__',  http.HttpServer
)

tarantool.socket.TcpSocket.new = function() 
  local self = _hx_new(tarantool.socket.TcpSocket.prototype)
  tarantool.socket.TcpSocket.super(self)
  return self
end
tarantool.socket.TcpSocket.super = function(self) 
end
tarantool.socket.TcpSocket.__name__ = true
tarantool.socket.TcpSocket.prototype = _hx_a(
  'assignSocket', function(self,s) 
    self.sock = s;
    local nameTable = self.sock:name();
    local host = nameTable.host;
    local port = nameTable.port;
    self.peer = tarantool.socket.Peer.new(host,port);
    self.input = tarantool.socket.SocketInput.new(self.sock);
    self.output = tarantool.socket.SocketOutput.new(self.sock);
  end,
  'connect', function(self,host,port,timeout) 
    local sock = tarantool.socket.native.NativeSocket.connect(host,port,timeout);
    self:assignSocket(sock);
  end,
  'bind', function(self,host,port,handler) 
    tarantool.socket.native.NativeSocket.tcp_server(host,port,function(s,e) 
      local socket = tarantool.socket.TcpSocket.new();
      socket:assignSocket(s);
      handler(socket);
    end);
  end
  ,'__class__',  tarantool.socket.TcpSocket
)

chocolate.WebSocket.new = function() 
  local self = _hx_new(chocolate.WebSocket.prototype)
  chocolate.WebSocket.super(self)
  return self
end
chocolate.WebSocket.super = function(self) 
  self.Handle = chocolate.InternalWebSocketHandle.new();
end
chocolate.WebSocket.__name__ = true
chocolate.WebSocket.prototype = _hx_a(
  'onConnect', function(self,call) 
    self.Handle.ConnectHandle = function(self,p,i) 
      call(p,i);
     end;
  end,
  'onData', function(self,call) 
    self.Handle.DataHandle = function(self,p,b,c) 
      call(p,b,c);
     end;
  end,
  'onClose', function(self,call) 
    self.Handle.CloseHandle = function(self,p) 
      call(p);
     end;
  end,
  'onError', function(self,call) 
    self.Handle.ErrorHandle = function(self,p,e) 
      call(p,e);
     end;
  end
  ,'__class__',  chocolate.WebSocket
)

http.handlers.websocket.IWSHandler.new = {}
http.handlers.websocket.IWSHandler.__name__ = true
http.handlers.websocket.IWSHandler.prototype = _hx_a(
  
  '__class__',  http.handlers.websocket.IWSHandler
)

chocolate.InternalWebSocketHandle.new = function() 
  local self = _hx_new(chocolate.InternalWebSocketHandle.prototype)
  chocolate.InternalWebSocketHandle.super(self)
  return self
end
chocolate.InternalWebSocketHandle.super = function(self) 
end
chocolate.InternalWebSocketHandle.__name__ = true
chocolate.InternalWebSocketHandle.__interfaces__ = {http.handlers.websocket.IWSHandler}
chocolate.InternalWebSocketHandle.prototype = _hx_a(
  'onConnect', function(self,p,c) 
    if (self.ConnectHandle ~= nil) then 
      self:ConnectHandle(p,c);
    end;
  end,
  'onData', function(self,p,b,c) 
    if (self.DataHandle ~= nil) then 
      self:DataHandle(p,b,c);
    end;
  end,
  'onClose', function(self,p) 
    if (self.CloseHandle ~= nil) then 
      self:CloseHandle(p);
    end;
  end,
  'onError', function(self,p,e) 
    if (self.ErrorHandle ~= nil) then 
      self:ErrorHandle(p,e);
    end;
  end
  ,'__class__',  chocolate.InternalWebSocketHandle
)

chocolate.Chocolate.new = function() 
  local self = _hx_new(chocolate.Chocolate.prototype)
  chocolate.Chocolate.super(self)
  return self
end
chocolate.Chocolate.super = function(self) 
  self._httpServer = http.HttpServer.new();
  self._routes = haxe.ds.StringMap.new();
  self._errorHandlers = haxe.ds.IntMap.new();
end
chocolate.Chocolate.__name__ = true
chocolate.Chocolate.prototype = _hx_a(
  'onHttpError', function(self,c,error) 
    if (self._errorHandlers:exists(error)) then 
      local call = self._errorHandlers:get(error);
      local req = chocolate.Request.new(c.request);
      local resp = call(req);
      self:writeResponse(c,resp);
    end;
  end,
  'writeResponse', function(self,c,response) 
    c.response:writeString(response:toString());
  end,
  'onHttpRequest', function(self,c) 
    local found = false;
    local kv = self._routes:iterator();
    while (kv:hasNext()) do 
      local kv1 = kv:next();
      if (kv1:isMatch(tink._Url.Url_Impl_.toString(c.request.url))) then 
        local req = chocolate.Request.new(c.request);
        local resp = kv1:process(req);
        self:writeResponse(c,resp);
        found = true;
        break;
      end;
      end;
    if (not found) then 
      _G.error(404,0);
    end;
  end,
  'get', function(self,pattern,call) 
    local this1 = self._routes;
    local v = chocolate.Route.new(pattern,call);
    local _this = this1;
    _this.v[pattern] = v;
    _this.k[pattern] = true;
  end,
  'post', function(self,pattern,call) 
    local this1 = self._routes;
    local v = chocolate.Route.new(pattern,call);
    local _this = this1;
    _this.v[pattern] = v;
    _this.k[pattern] = true;
  end,
  'onError', function(self,err,call) 
    self._errorHandlers:set(err,call);
  end,
  'listen', function(self,options) 
    if (options.WebSocket ~= nil) then 
      local wshandler = http.handlers.websocket.WebSocketHandler.new(chocolate.Chocolate.WebSocket.Handle);
      self._httpServer:addHandler(wshandler);
    end;
    local errorHandler = http.handlers.ErrorHandler.new(_hx_bind(self,self.onHttpError));
    self._httpServer:addHandler(errorHandler);
    if (options.StaticDir ~= nil) then 
      local staticHandler = http.handlers.StaticHandler.new();
      staticHandler:addPath(options.StaticDir);
      self._httpServer:addHandler(staticHandler);
    end;
    local httpHandler = http.handlers.HttpHandler.new(_hx_bind(self,self.onHttpRequest));
    self._httpServer:addHandler(httpHandler);
    self._httpServer:bind("*",options.Port);
  end
  ,'__class__',  chocolate.Chocolate
)

chocolate.Request.new = function(request) 
  local self = _hx_new(chocolate.Request.prototype)
  chocolate.Request.super(self,request)
  return self
end
chocolate.Request.super = function(self,request) 
  self.Headers = request.headers;
end
chocolate.Request.__name__ = true
chocolate.Request.prototype = _hx_a(
  
  '__class__',  chocolate.Request
)

chocolate.Route.new = function(pattern,call) 
  local self = _hx_new(chocolate.Route.prototype)
  chocolate.Route.super(self,pattern,call)
  return self
end
chocolate.Route.super = function(self,pattern,call) 
  self._pattern = pattern;
  self._call = function(self,r) 
    do return call(r) end
   end;
end
chocolate.Route.__name__ = true
chocolate.Route.prototype = _hx_a(
  'isMatch', function(self,path) 
    local items1 = path:split("/");
    local items2 = self._pattern:split("/");
    if (items1.length ~= items2.length) then 
      do return false end;
    end;
    local _g1 = 1;
    local _g = items2.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i2 = _g1 - 1;
      local s2 = items2[i2];
      local _g3 = 1;
      local _g2 = items1.length;
      local _hx_break_1 = false;
      while (_g3 < _g2) do 
        repeat 
        _g3 = _g3 + 1;
        local i1 = _g3 - 1;
        local s1 = items1[i1];
        if (s2 ~= s1) then 
          break;
        end;
        do return true end;
        
      until true
      if _hx_break_2 then _hx_break_2 = false; break; end
      end;
      end;
    do return false end
  end,
  'process', function(self,request) 
    do return self:_call(request) end
  end
  ,'__class__',  chocolate.Route
)

chocolate.response._Response.Response_Impl_.new = {}
chocolate.response._Response.Response_Impl_.__name__ = true
chocolate.response._Response.Response_Impl_._new = function(d) 
  local this1 = d;
  do return this1 end;
end
chocolate.response._Response.Response_Impl_.fromString = function(s) 
  do return chocolate.response._Response.Response_Impl_._new(chocolate.response.StringResponse.new(s)) end;
end
chocolate.response._Response.Response_Impl_.fromResponse = function(s) 
  do return chocolate.response._Response.Response_Impl_._new(s) end;
end

chocolate.response.StringResponse.new = function(s) 
  local self = _hx_new(chocolate.response.StringResponse.prototype)
  chocolate.response.StringResponse.super(self,s)
  return self
end
chocolate.response.StringResponse.super = function(self,s) 
  self.data = s;
end
chocolate.response.StringResponse.__name__ = true
chocolate.response.StringResponse.prototype = _hx_a(
  'toString', function(self) 
    do return self.data end
  end
  ,'__class__',  chocolate.response.StringResponse
)
chocolate.response.StringResponse.__super__ = chocolate.response.AbstractResponse
setmetatable(chocolate.response.StringResponse.prototype,{__index=chocolate.response.AbstractResponse.prototype})
_hxClasses["haxe.StackItem"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="CFunction","Module","FilePos","Method","LocalFunction"},5)}
haxe.StackItem = _hxClasses["haxe.StackItem"];
haxe.StackItem.CFunction = _hx_tab_array({[0]="CFunction",0,__enum__ = haxe.StackItem},2)

haxe.StackItem.Module = function(m) local _x = _hx_tab_array({[0]="Module",1,m,__enum__=haxe.StackItem}, 3); return _x; end 
haxe.StackItem.FilePos = function(s,file,line) local _x = _hx_tab_array({[0]="FilePos",2,s,file,line,__enum__=haxe.StackItem}, 5); return _x; end 
haxe.StackItem.Method = function(classname,method) local _x = _hx_tab_array({[0]="Method",3,classname,method,__enum__=haxe.StackItem}, 4); return _x; end 
haxe.StackItem.LocalFunction = function(v) local _x = _hx_tab_array({[0]="LocalFunction",4,v,__enum__=haxe.StackItem}, 3); return _x; end 

haxe.CallStack.new = {}
haxe.CallStack.__name__ = true
haxe.CallStack.toString = function(stack) 
  local b = StringBuf.new();
  local _g = 0;
  while (_g < stack.length) do 
    local s = stack[_g];
    _g = _g + 1;
    local str = "\nCalled from ";
    _G.table.insert(b.b,str);
    local b1 = b;
    b1.length = b1.length + str.length;
    haxe.CallStack.itemToString(b,s);
    end;
  do return _G.table.concat(b.b) end;
end
haxe.CallStack.itemToString = function(b,s) 
  local s1 = s[1];
  if (s1) == 0 then 
    local str = "a C function";
    _G.table.insert(b.b,str);
    local b1 = b;
    b1.length = b1.length + str.length;
  elseif (s1) == 1 then 
    local m = s[2];
    local str1 = "module ";
    _G.table.insert(b.b,str1);
    local b2 = b;
    b2.length = b2.length + str1.length;
    local str2 = Std.string(m);
    _G.table.insert(b.b,str2);
    local b3 = b;
    b3.length = b3.length + str2.length;
  elseif (s1) == 2 then 
    local line = s[4];
    local file = s[3];
    local s2 = s[2];
    if (s2 ~= nil) then 
      haxe.CallStack.itemToString(b,s2);
      local str3 = " (";
      _G.table.insert(b.b,str3);
      local b4 = b;
      b4.length = b4.length + str3.length;
    end;
    local str4 = Std.string(file);
    _G.table.insert(b.b,str4);
    local b5 = b;
    b5.length = b5.length + str4.length;
    local str5 = " line ";
    _G.table.insert(b.b,str5);
    local b6 = b;
    b6.length = b6.length + str5.length;
    local str6 = Std.string(line);
    _G.table.insert(b.b,str6);
    local b7 = b;
    b7.length = b7.length + str6.length;
    if (s2 ~= nil) then 
      local str7 = ")";
      _G.table.insert(b.b,str7);
      local b8 = b;
      b8.length = b8.length + str7.length;
    end;
  elseif (s1) == 3 then 
    local meth = s[3];
    local cname = s[2];
    local str8 = Std.string(cname);
    _G.table.insert(b.b,str8);
    local b9 = b;
    b9.length = b9.length + str8.length;
    local str9 = ".";
    _G.table.insert(b.b,str9);
    local b10 = b;
    b10.length = b10.length + str9.length;
    local str10 = Std.string(meth);
    _G.table.insert(b.b,str10);
    local b11 = b;
    b11.length = b11.length + str10.length;
  elseif (s1) == 4 then 
    local n = s[2];
    local str11 = "local function #";
    _G.table.insert(b.b,str11);
    local b12 = b;
    b12.length = b12.length + str11.length;
    local str12 = Std.string(n);
    _G.table.insert(b.b,str12);
    local b13 = b;
    b13.length = b13.length + str12.length; end;
end

haxe.IMap.new = {}
haxe.IMap.__name__ = true
haxe.IMap.prototype = _hx_a(
  
  '__class__',  haxe.IMap
)

haxe._EntryPoint.Lock.new = function() 
  local self = _hx_new(haxe._EntryPoint.Lock.prototype)
  haxe._EntryPoint.Lock.super(self)
  return self
end
haxe._EntryPoint.Lock.super = function(self) 
end
haxe._EntryPoint.Lock.__name__ = true
haxe._EntryPoint.Lock.prototype = _hx_a(
  
  '__class__',  haxe._EntryPoint.Lock
)

haxe._EntryPoint.Mutex.new = function() 
  local self = _hx_new(haxe._EntryPoint.Mutex.prototype)
  haxe._EntryPoint.Mutex.super(self)
  return self
end
haxe._EntryPoint.Mutex.super = function(self) 
end
haxe._EntryPoint.Mutex.__name__ = true
haxe._EntryPoint.Mutex.prototype = _hx_a(
  
  '__class__',  haxe._EntryPoint.Mutex
)

haxe.EntryPoint.new = {}
haxe.EntryPoint.__name__ = true
haxe.EntryPoint.processEvents = function() 
  while (true) do 
    local _this = haxe.EntryPoint.mutex;
    local f = haxe.EntryPoint.pending:shift();
    local _this1 = haxe.EntryPoint.mutex;
    if (f == nil) then 
      break;
    end;
    f();
    end;
  if ((haxe.MainLoop.pending == nil) and (haxe.EntryPoint.threadCount == 0)) then 
    do return -1 end;
  end;
  do return haxe.MainLoop.tick() end;
end
haxe.EntryPoint.run = function() 
  while (true) do 
    local nextTick = haxe.EntryPoint.processEvents();
    if (nextTick < 0) then 
      break;
    end;
    if (nextTick > 0) then 
      local _this = haxe.EntryPoint.sleepLock;
    end;
    end;
end

haxe.Log.new = {}
haxe.Log.__name__ = true
haxe.Log.trace = function(v,infos) 
  local str = nil;
  if (infos ~= nil) then 
    str = infos.fileName .. ":" .. infos.lineNumber .. ": " .. Std.string(v);
    if (infos.customParams ~= nil) then 
      str = str .. ("," .. infos.customParams:join(","));
    end;
  else
    str = v;
  end;
  if (str == nil) then 
    str = "null";
  end;
  _hx_print(str);
end

haxe.MainEvent.new = function(f,p) 
  local self = _hx_new(haxe.MainEvent.prototype)
  haxe.MainEvent.super(self,f,p)
  return self
end
haxe.MainEvent.super = function(self,f,p) 
  self.f = _hx_funcToField(f);
  self.priority = p;
  self.nextRun = -1;
end
haxe.MainEvent.__name__ = true
haxe.MainEvent.prototype = _hx_a(
  'delay', function(self,t) 
    self.nextRun = (function() 
      local _hx_1
      if (t == nil) then 
      _hx_1 = -1; else 
      _hx_1 = Sys.time() + t; end
      return _hx_1
    end )();
  end,
  'stop', function(self) 
    if (self.f == nil) then 
      do return end;
    end;
    self.f = nil;
    self.nextRun = -1;
    if (self.prev == nil) then 
      haxe.MainLoop.pending = self.next;
    else
      self.prev.next = self.next;
    end;
    if (self.next ~= nil) then 
      self.next.prev = self.prev;
    end;
  end
  ,'__class__',  haxe.MainEvent
)

haxe.MainLoop.new = {}
haxe.MainLoop.__name__ = true
haxe.MainLoop.add = function(f,priority) 
  if (priority == nil) then 
    priority = 0;
  end;
  if (f == nil) then 
    _G.error("Event function is null",0);
  end;
  local e = haxe.MainEvent.new(f,priority);
  local head = haxe.MainLoop.pending;
  if (head ~= nil) then 
    head.prev = e;
  end;
  e.next = head;
  haxe.MainLoop.pending = e;
  do return e end;
end
haxe.MainLoop.sortEvents = function() 
  local list = haxe.MainLoop.pending;
  if (list == nil) then 
    do return end;
  end;
  local insize = 1;
  local nmerges;
  local psize = 0;
  local qsize = 0;
  local p;
  local q;
  local e;
  local tail;
  while (true) do 
    p = list;
    list = nil;
    tail = nil;
    nmerges = 0;
    while (p ~= nil) do 
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      local _g1 = 0;
      local _g = insize;
      while (_g1 < _g) do 
        _g1 = _g1 + 1;
        local i = _g1 - 1;
        psize = psize + 1;
        q = q.next;
        if (q == nil) then 
          break;
        end;
        end;
      qsize = insize;
      while ((psize > 0) or ((qsize > 0) and (q ~= nil))) do 
        if (psize == 0) then 
          e = q;
          q = q.next;
          qsize = qsize - 1;
        else
          if (((qsize == 0) or (q == nil)) or ((p.priority > q.priority) or ((p.priority == q.priority) and (p.nextRun <= q.nextRun)))) then 
            e = p;
            p = p.next;
            psize = psize - 1;
          else
            e = q;
            q = q.next;
            qsize = qsize - 1;
          end;
        end;
        if (tail ~= nil) then 
          tail.next = e;
        else
          list = e;
        end;
        e.prev = tail;
        tail = e;
        end;
      p = q;
      end;
    tail.next = nil;
    if (nmerges <= 1) then 
      break;
    end;
    insize = insize * 2;
    end;
  list.prev = nil;
  haxe.MainLoop.pending = list;
end
haxe.MainLoop.tick = function() 
  haxe.MainLoop.sortEvents();
  local e = haxe.MainLoop.pending;
  local now = Sys.time();
  local wait = 1e9;
  while (e ~= nil) do 
    local next = e.next;
    local wt = e.nextRun - now;
    if ((e.nextRun < 0) or (wt <= 0)) then 
      wait = 0;
      if (e.f ~= nil) then 
        e:f();
      end;
    else
      if (wait > wt) then 
        wait = wt;
      end;
    end;
    e = next;
    end;
  do return wait end;
end

haxe.Timer.new = function(time_ms) 
  local self = _hx_new(haxe.Timer.prototype)
  haxe.Timer.super(self,time_ms)
  return self
end
haxe.Timer.super = function(self,time_ms) 
  local _gthis = self;
  local dt = time_ms / 1000;
  self.event = haxe.MainLoop.add(function() 
    local _gthis1 = _gthis.event;
    _gthis1.nextRun = _gthis1.nextRun + dt;
    _gthis:run();
  end);
  self.event:delay(dt);
end
haxe.Timer.__name__ = true
haxe.Timer.delay = function(f,time_ms) 
  local t = haxe.Timer.new(time_ms);
  t.run = function(self) 
    t:stop();
    f();
   end;
  do return t end;
end
haxe.Timer.prototype = _hx_a(
  'stop', function(self) 
    if (self.event ~= nil) then 
      self.event:stop();
      self.event = nil;
    end;
  end,
  'run', function(self) 
  end
  ,'__class__',  haxe.Timer
)

haxe.Utf8.new = {}
haxe.Utf8.__name__ = true
haxe.Utf8.charWidth = function(c) 
  if ((c > 0) and (c <= 127)) then 
    do return 1 end;
  else
    if ((c >= 194) and (c <= 223)) then 
      do return 2 end;
    else
      if ((c >= 224) and (c <= 239)) then 
        do return 3 end;
      else
        if ((c >= 240) and (c <= 244)) then 
          do return 4 end;
        else
          do return nil end;
        end;
      end;
    end;
  end;
end
haxe.Utf8.char = function(unicode) 
  if (unicode <= 127) then 
    do return _G.string.char(unicode) end;
  else
    if (unicode <= 2047) then 
      local b0 = 192 + _G.math.floor(unicode / 64);
      local b1 = 128 + (_G.math.fmod(unicode, 64));
      do return _G.string.char(b0,b1) end;
    else
      if (unicode <= 65535) then 
        local b01 = 224 + _G.math.floor(unicode / 4096);
        local b11 = 128 + (_G.math.fmod(_G.math.floor(unicode / 64), 64));
        local b2 = 128 + (_G.math.fmod(unicode, 64));
        do return _G.string.char(b01,b11,b2) end;
      else
        if (unicode <= 1114111) then 
          local code = unicode;
          local b3 = 128 + (_G.math.fmod(code, 64));
          code = _G.math.floor(code / 64);
          local b21 = 128 + (_G.math.fmod(code, 64));
          code = _G.math.floor(code / 64);
          local b12 = 128 + (_G.math.fmod(code, 64));
          code = _G.math.floor(code / 64);
          local b02 = 240 + code;
          do return _G.string.char(b02,b12,b21,b3) end;
        else
          _G.error("Unicode greater than U+10FFFF",0);
        end;
      end;
    end;
  end;
end

haxe.io.Bytes.new = function(length,b) 
  local self = _hx_new(haxe.io.Bytes.prototype)
  haxe.io.Bytes.super(self,length,b)
  return self
end
haxe.io.Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
haxe.io.Bytes.__name__ = true
haxe.io.Bytes.alloc = function(length) 
  local a = Array.new();
  local _g1 = 0;
  local _g = length;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    a:push(0);
    end;
  do return haxe.io.Bytes.new(length,a) end;
end
haxe.io.Bytes.ofString = function(s) 
  local _g = _hx_tab_array({ }, 0);
  local _g2 = 0;
  local _g1 = s.length;
  while (_g2 < _g1) do 
    _g2 = _g2 + 1;
    local c = _g2 - 1;
    _g:push(_G.string.byte(s,c + 1));
    end;
  local bytes = _g;
  do return haxe.io.Bytes.new(bytes.length,bytes) end;
end
haxe.io.Bytes.prototype = _hx_a(
  'blit', function(self,pos,src,srcpos,len) 
    if (((((pos < 0) or (srcpos < 0)) or (len < 0)) or ((pos + len) > self.length)) or ((srcpos + len) > src.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b1 = self.b;
    local b2 = src.b;
    if ((b1 == b2) and (pos > srcpos)) then 
      local i = len;
      while (i > 0) do 
        i = i - 1;
        b1[i + pos] = b2[i + srcpos];
        end;
      do return end;
    end;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i1 = _g1 - 1;
      b1[i1 + pos] = b2[i1 + srcpos];
      end;
  end,
  'sub', function(self,pos,len) 
    if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    do return haxe.io.Bytes.new(len,self.b:slice(pos,pos + len)) end
  end,
  'getString', function(self,pos,len) 
    if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b = self.b.length;
    local begin = lua.Boot.__cast((function() 
      local _hx_1
      if (Math.isNaN(pos) or Math.isNaN(b)) then 
      _hx_1 = (0/0); else 
      _hx_1 = _G.math.min(pos,b); end
      return _hx_1
    end )() , Int);
    local a = pos + len;
    local b1 = self.b.length;
    local _end = lua.Boot.__cast((function() 
      local _hx_2
      if (Math.isNaN(a) or Math.isNaN(b1)) then 
      _hx_2 = (0/0); else 
      _hx_2 = _G.math.min(a,b1); end
      return _hx_2
    end )() , Int);
    local _g = _hx_tab_array({ }, 0);
    local _g2 = begin;
    local _g1 = _end;
    while (_g2 < _g1) do 
      _g2 = _g2 + 1;
      local i = _g2 - 1;
      _g:push(_G.string.char(self.b[i]));
      end;
    do return _g:join("") end
  end,
  'toString', function(self) 
    do return self:getString(0,self.length) end
  end
  ,'__class__',  haxe.io.Bytes
)

haxe.crypto.Base64.new = {}
haxe.crypto.Base64.__name__ = true
haxe.crypto.Base64.encode = function(bytes,complement) 
  if (complement == nil) then 
    complement = true;
  end;
  local str = haxe.crypto.BaseCode.new(haxe.crypto.Base64.BYTES):encodeBytes(bytes):toString();
  if (complement) then 
    local _g = _G.math.fmod(bytes.length, 3);
    local _g1 = _g;
    if (_g1) == 1 then 
      str = str .. "==";
    elseif (_g1) == 2 then 
      str = str .. "=";else end;
  end;
  do return str end;
end

haxe.crypto.BaseCode.new = function(base) 
  local self = _hx_new(haxe.crypto.BaseCode.prototype)
  haxe.crypto.BaseCode.super(self,base)
  return self
end
haxe.crypto.BaseCode.super = function(self,base) 
  local len = base.length;
  local nbits = 1;
  while (len > (_hx_bit.lshift(1,nbits))) do 
    nbits = nbits + 1;
    end;
  if ((nbits > 8) or (len ~= (_hx_bit.lshift(1,nbits)))) then 
    _G.error("BaseCode : base length must be a power of two.",0);
  end;
  self.base = base;
  self.nbits = nbits;
end
haxe.crypto.BaseCode.__name__ = true
haxe.crypto.BaseCode.prototype = _hx_a(
  'encodeBytes', function(self,b) 
    local nbits = self.nbits;
    local base = self.base;
    local size = Std.int((b.length * 8) / nbits);
    local out = haxe.io.Bytes.alloc(size + (function() 
      local _hx_1
      if ((_G.math.fmod(b.length * 8, nbits)) == 0) then 
      _hx_1 = 0; else 
      _hx_1 = 1; end
      return _hx_1
    end )());
    local buf = 0;
    local curbits = 0;
    local mask = (_hx_bit.lshift(1,nbits)) - 1;
    local pin = 0;
    local pout = 0;
    while (pout < size) do 
      while (curbits < nbits) do 
        curbits = curbits + 8;
        buf = _hx_bit.lshift(buf,8);
        pin = pin + 1;
        buf = _hx_bit.bor(buf,b.b[pin - 1]);
        end;
      curbits = curbits - nbits;
      pout = pout + 1;
      out.b[pout - 1] = _hx_bit.band(base.b[_hx_bit.band(_hx_bit.arshift(buf,curbits),mask)],255);
      end;
    if (curbits > 0) then 
      pout = pout + 1;
      out.b[pout - 1] = _hx_bit.band(base.b[_hx_bit.band(_hx_bit.lshift(buf,nbits - curbits),mask)],255);
    end;
    do return out end
  end,
  'initTable', function(self) 
    local tbl = Array.new();
    local _g = 0;
    while (_g < 256) do 
      _g = _g + 1;
      local i = _g - 1;
      tbl[i] = -1;
      end;
    local _g1 = 0;
    local _g2 = self.base.length;
    while (_g1 < _g2) do 
      _g1 = _g1 + 1;
      local i1 = _g1 - 1;
      tbl[self.base.b[i1]] = i1;
      end;
    self.tbl = tbl;
  end,
  'decodeBytes', function(self,b) 
    local nbits = self.nbits;
    local base = self.base;
    if (self.tbl == nil) then 
      self:initTable();
    end;
    local tbl = self.tbl;
    local size = _hx_bit.arshift(b.length * nbits,3);
    local out = haxe.io.Bytes.alloc(size);
    local buf = 0;
    local curbits = 0;
    local pin = 0;
    local pout = 0;
    while (pout < size) do 
      while (curbits < 8) do 
        curbits = curbits + nbits;
        buf = _hx_bit.lshift(buf,nbits);
        pin = pin + 1;
        local i = tbl[b.b[pin - 1]];
        if (i == -1) then 
          _G.error("BaseCode : invalid encoded char",0);
        end;
        buf = _hx_bit.bor(buf,i);
        end;
      curbits = curbits - 8;
      pout = pout + 1;
      out.b[pout - 1] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(buf,curbits),255),255);
      end;
    do return out end
  end
  ,'__class__',  haxe.crypto.BaseCode
)

haxe.crypto.Sha1.new = function() 
  local self = _hx_new(haxe.crypto.Sha1.prototype)
  haxe.crypto.Sha1.super(self)
  return self
end
haxe.crypto.Sha1.super = function(self) 
end
haxe.crypto.Sha1.__name__ = true
haxe.crypto.Sha1.encode = function(s) 
  local sh = haxe.crypto.Sha1.new();
  local h = sh:doEncode(haxe.crypto.Sha1.str2blks(s));
  do return sh:hex(h) end;
end
haxe.crypto.Sha1.str2blks = function(s) 
  local s1 = haxe.io.Bytes.ofString(s);
  local nblk = (_hx_bit.arshift(s1.length + 8,6)) + 1;
  local blks = Array.new();
  local _g1 = 0;
  local _g = nblk * 16;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    blks[i] = 0;
    end;
  local _g11 = 0;
  local _g2 = s1.length;
  while (_g11 < _g2) do 
    _g11 = _g11 + 1;
    local i1 = _g11 - 1;
    local p = _hx_bit.arshift(i1,2);
    local blks1 = blks;
    local p1 = p;
    blks1[p1] = _hx_bit.bor(blks1[p1],_hx_bit.lshift(s1.b[i1],24 - (_hx_bit.lshift((_hx_bit.band(i1,3)),3))));
    end;
  local i2 = s1.length;
  local p2 = _hx_bit.arshift(i2,2);
  local blks2 = blks;
  local p3 = p2;
  blks2[p3] = _hx_bit.bor(blks2[p3],_hx_bit.lshift(128,24 - (_hx_bit.lshift((_hx_bit.band(i2,3)),3))));
  blks[(nblk * 16) - 1] = s1.length * 8;
  do return blks end;
end
haxe.crypto.Sha1.prototype = _hx_a(
  'doEncode', function(self,x) 
    local w = Array.new();
    local a = 1732584193;
    local b = -271733879;
    local c = -1732584194;
    local d = 271733878;
    local e = -1009589776;
    local i = 0;
    while (i < x.length) do 
      local olda = a;
      local oldb = b;
      local oldc = c;
      local oldd = d;
      local olde = e;
      local j = 0;
      while (j < 80) do 
        if (j < 16) then 
          w[j] = x[i + j];
        else
          local num = _hx_bit.bxor(_hx_bit.bxor(_hx_bit.bxor(w[j - 3],w[j - 8]),w[j - 14]),w[j - 16]);
          w[j] = _hx_bit.bor(_hx_bit.lshift(num,1),_hx_bit.rshift(num,31));
        end;
        local t = ((((_hx_bit.bor(_hx_bit.lshift(a,5),_hx_bit.rshift(a,27))) + self:ft(j,b,c,d)) + e) + w[j]) + self:kt(j);
        e = d;
        d = c;
        c = _hx_bit.bor(_hx_bit.lshift(b,30),_hx_bit.rshift(b,2));
        b = a;
        a = t;
        j = j + 1;
        end;
      a = a + olda;
      b = b + oldb;
      c = c + oldc;
      d = d + oldd;
      e = e + olde;
      i = i + 16;
      end;
    do return _hx_tab_array({[0]=a, b, c, d, e }, 5) end
  end,
  'ft', function(self,t,b,c,d) 
    if (t < 20) then 
      do return _hx_bit.bor(_hx_bit.band(b,c),_hx_bit.band(_hx_bit.bnot(b),d)) end;
    end;
    if (t < 40) then 
      do return _hx_bit.bxor(_hx_bit.bxor(b,c),d) end;
    end;
    if (t < 60) then 
      do return _hx_bit.bor(_hx_bit.bor(_hx_bit.band(b,c),_hx_bit.band(b,d)),_hx_bit.band(c,d)) end;
    end;
    do return _hx_bit.bxor(_hx_bit.bxor(b,c),d) end
  end,
  'kt', function(self,t) 
    if (t < 20) then 
      do return 1518500249 end;
    end;
    if (t < 40) then 
      do return 1859775393 end;
    end;
    if (t < 60) then 
      do return -1894007588 end;
    end;
    do return -899497514 end
  end,
  'hex', function(self,a) 
    local str = "";
    local _g = 0;
    while (_g < a.length) do 
      local num = a[_g];
      _g = _g + 1;
      str = str .. StringTools.hex(num,8);
      end;
    do return str:toLowerCase() end
  end
  ,'__class__',  haxe.crypto.Sha1
)
_hxClasses["haxe.ds.Either"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Left","Right"},2)}
haxe.ds.Either = _hxClasses["haxe.ds.Either"];
haxe.ds.Either.Left = function(v) local _x = _hx_tab_array({[0]="Left",0,v,__enum__=haxe.ds.Either}, 3); return _x; end 
haxe.ds.Either.Right = function(v) local _x = _hx_tab_array({[0]="Right",1,v,__enum__=haxe.ds.Either}, 3); return _x; end 

haxe.ds.IntMap.new = function() 
  local self = _hx_new(haxe.ds.IntMap.prototype)
  haxe.ds.IntMap.super(self)
  return self
end
haxe.ds.IntMap.super = function(self) 
  self.h = _hx_e();
end
haxe.ds.IntMap.__name__ = true
haxe.ds.IntMap.__interfaces__ = {haxe.IMap}
haxe.ds.IntMap.prototype = _hx_a(
  'set', function(self,key,value) 
    self.h[key] = value;
  end,
  'get', function(self,key) 
    do return self.h[key] end
  end,
  'exists', function(self,key) 
    local o = self.h;
    local field = key;
    if (o.__fields__ ~= nil) then 
      do return o.__fields__[field] ~= nil end;
    else
      do return o[field] ~= nil end;
    end;
  end
  ,'__class__',  haxe.ds.IntMap
)
_hxClasses["haxe.ds.Option"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Some","None"},2)}
haxe.ds.Option = _hxClasses["haxe.ds.Option"];
haxe.ds.Option.Some = function(v) local _x = _hx_tab_array({[0]="Some",0,v,__enum__=haxe.ds.Option}, 3); return _x; end 
haxe.ds.Option.None = _hx_tab_array({[0]="None",1,__enum__ = haxe.ds.Option},2)


haxe.ds.StringMap.new = function() 
  local self = _hx_new(haxe.ds.StringMap.prototype)
  haxe.ds.StringMap.super(self)
  return self
end
haxe.ds.StringMap.super = function(self) 
  self.v = {}
  self.k = {}
end
haxe.ds.StringMap.__name__ = true
haxe.ds.StringMap.__interfaces__ = {haxe.IMap}
haxe.ds.StringMap.prototype = _hx_a(
  'set', function(self,key,value) 
    self.v[key] = value;
    self.k[key] = true;
  end,
  'get', function(self,key) 
    do return self.v[key] end
  end,
  'exists', function(self,key) 
    do return (self.k[key] or false) end
  end,
  'keys', function(self) 
    local cur = _hx_tab_array({ }, 0);
    for _k,_v in pairs(self.k) do
			if(_v)then cur:push(_k) end
		end;
    do return _hx_o({__fields__={next=true,hasNext=true},next=function() 
      local ret = cur:pop();
      do return ret end;
    end,hasNext=function() 
      do return cur.length > 0 end;
    end}) end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local it = self:keys();
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function() 
      do return it:hasNext() end;
    end,next=function() 
      do return _gthis.v[it:next()] end;
    end}) end
  end
  ,'__class__',  haxe.ds.StringMap
)

haxe.io.BytesBuffer.new = function() 
  local self = _hx_new(haxe.io.BytesBuffer.prototype)
  haxe.io.BytesBuffer.super(self)
  return self
end
haxe.io.BytesBuffer.super = function(self) 
  self.b = Array.new();
end
haxe.io.BytesBuffer.__name__ = true
haxe.io.BytesBuffer.prototype = _hx_a(
  'getBytes', function(self) 
    local bytes = haxe.io.Bytes.new(self.b.length,self.b);
    self.b = nil;
    do return bytes end
  end
  ,'__class__',  haxe.io.BytesBuffer
)

haxe.io.Input.new = {}
haxe.io.Input.__name__ = true
haxe.io.Input.prototype = _hx_a(
  'readByte', function(self) 
    _G.error("Not implemented",0);
  end,
  'readBytes', function(self,s,pos,len) 
    local k = len;
    local b = s.b;
    if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        while (k > 0) do 
          b[pos] = self:readByte();
          pos = pos + 1;
          k = k - 1;
          end;
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Eof) ) then 
        local eof = _hx_1
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    do return len - k end
  end,
  'readFullBytes', function(self,s,pos,len) 
    while (len > 0) do 
      local k = self:readBytes(s,pos,len);
      if (k == 0) then 
        _G.error(haxe.io.Error.Blocked,0);
      end;
      pos = pos + k;
      len = len - k;
      end;
  end,
  'read', function(self,nbytes) 
    local s = haxe.io.Bytes.alloc(nbytes);
    local p = 0;
    while (nbytes > 0) do 
      local k = self:readBytes(s,p,nbytes);
      if (k == 0) then 
        _G.error(haxe.io.Error.Blocked,0);
      end;
      p = p + k;
      nbytes = nbytes - k;
      end;
    do return s end
  end,
  'readLine', function(self) 
    local buf = haxe.io.BytesBuffer.new();
    local last;
    local s;
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        while (true) do 
          last = self:readByte();
          if (not (last ~= 10)) then 
            break;
          end;
          buf.b:push(last);
          end;
        s = buf:getBytes():toString();
        if (s:charCodeAt(s.length - 1) == 13) then 
          s = s:substr(0,-1);
        end;
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,haxe.io.Eof) ) then 
        local e = _hx_1
        s = buf:getBytes():toString();
        if (s.length == 0) then 
          _G.error(e,0);
        end;
      else _G.error(_hx_1)
      end
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    do return s end
  end,
  'readString', function(self,len) 
    local b = haxe.io.Bytes.alloc(len);
    self:readFullBytes(b,0,len);
    do return b:toString() end
  end
  ,'__class__',  haxe.io.Input
)

haxe.io.Eof.new = {}
haxe.io.Eof.__name__ = true
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
  ,'__class__',  haxe.io.Eof
)
_hxClasses["haxe.io.Error"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
haxe.io.Error = _hxClasses["haxe.io.Error"];
haxe.io.Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = haxe.io.Error},2)

haxe.io.Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = haxe.io.Error},2)

haxe.io.Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = haxe.io.Error},2)

haxe.io.Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=haxe.io.Error}, 3); return _x; end 

haxe.io.Output.new = {}
haxe.io.Output.__name__ = true
haxe.io.Output.prototype = _hx_a(
  'writeByte', function(self,c) 
    _G.error("Not implemented",0);
  end,
  'writeBytes', function(self,s,pos,len) 
    if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b = s.b;
    local k = len;
    while (k > 0) do 
      self:writeByte(b[pos]);
      pos = pos + 1;
      k = k - 1;
      end;
    do return len end
  end,
  'close', function(self) 
  end,
  'write', function(self,s) 
    local l = s.length;
    local p = 0;
    while (l > 0) do 
      local k = self:writeBytes(s,p,l);
      if (k == 0) then 
        _G.error(haxe.io.Error.Blocked,0);
      end;
      p = p + k;
      l = l - k;
      end;
  end,
  'writeFullBytes', function(self,s,pos,len) 
    while (len > 0) do 
      local k = self:writeBytes(s,pos,len);
      pos = pos + k;
      len = len - k;
      end;
  end,
  'writeString', function(self,s) 
    local b = haxe.io.Bytes.ofString(s);
    self:writeFullBytes(b,0,b.length);
  end
  ,'__class__',  haxe.io.Output
)

http.HttpContext.new = function(request,response) 
  local self = _hx_new(http.HttpContext.prototype)
  http.HttpContext.super(self,request,response)
  return self
end
http.HttpContext.super = function(self,request,response) 
  self.request = request;
  self.response = response;
end
http.HttpContext.__name__ = true
http.HttpContext.prototype = _hx_a(
  
  '__class__',  http.HttpContext
)
_hxClasses["http.HttpMethod"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="get","post","put","delete"},4)}
http.HttpMethod = _hxClasses["http.HttpMethod"];
http.HttpMethod.get = _hx_tab_array({[0]="get",0,__enum__ = http.HttpMethod},2)

http.HttpMethod.post = _hx_tab_array({[0]="post",1,__enum__ = http.HttpMethod},2)

http.HttpMethod.put = _hx_tab_array({[0]="put",2,__enum__ = http.HttpMethod},2)

http.HttpMethod.delete = _hx_tab_array({[0]="delete",3,__enum__ = http.HttpMethod},2)


http.HttpRequest.new = function(channel) 
  local self = _hx_new(http.HttpRequest.prototype)
  http.HttpRequest.super(self,channel)
  return self
end
http.HttpRequest.super = function(self,channel) 
  self:readHeaders(channel);
  self:readBody(channel);
end
http.HttpRequest.__name__ = true
http.HttpRequest.prototype = _hx_a(
  'readHeaders', function(self,channel) 
    local text = channel.input:readLine();
    if (text == nil) then 
      _G.error("Connection closed",0);
    end;
    local line = StringTools.trim(text);
    local parts = line:split(" ");
    if (parts.length ~= 3) then 
      _G.error(400,0);
    end;
    self.method = Type.createEnum(http.HttpMethod,parts[0]:toLowerCase(),nil);
    self.url = tink._Url.Url_Impl_.parse(parts[1]);
    self.headers = haxe.ds.StringMap.new();
    line = StringTools.trim(channel.input:readLine());
    while (line.length > 0) do 
      local head = line:split(": ");
      if (head.length < 2) then 
        _G.error(400,0);
      end;
      local v = head[1];
      local _this = self.headers;
      local key = head[0];
      _this.v[key] = v;
      _this.k[key] = true;
      line = StringTools.trim(channel.input:readLine());
      end;
  end,
  'readBody', function(self,channel) 
    self.body = nil;
    if (self.method == http.HttpMethod.get) then 
      do return end;
    end;
    local this1 = self.headers;
    if ((this1.k["Content-Length"] or false)) then 
      local this2 = self.headers;
      local len = Std.parseInt(this2.v["Content-Length"]);
      self.body = haxe.io.Bytes.ofString(channel.input:readString(len));
    else
      local this3 = self.headers;
      local tmp = this3.v["Transfer-Encoding"] == "chunked";
    end;
  end
  ,'__class__',  http.HttpRequest
)

http.HttpResponse.new = function(channel) 
  local self = _hx_new(http.HttpResponse.prototype)
  http.HttpResponse.super(self,channel)
  return self
end
http.HttpResponse.super = function(self,channel) 
  self.status = 200;
  self.channel = channel;
  self.headers = haxe.ds.StringMap.new();
  self:reset();
end
http.HttpResponse.__name__ = true
http.HttpResponse.prototype = _hx_a(
  'writeHeaders', function(self) 
    local this1 = self.headers;
    local v = Std.string(self.buffer.b.length);
    local _this = this1;
    local key = "Content-Length";
    _this.v[key] = v;
    _this.k[key] = true;
    local _this1 = self.headers;
    local key1 = "Server";
    _this1.v[key1] = "tyrant";
    _this1.k[key1] = true;
    local k = self.headers:keys();
    while (k:hasNext()) do 
      local k1 = k:next();
      local this2 = self.headers;
      local v1 = this2.v[k1];
      self.channel.output:writeString("" .. k1 .. ": " .. v1 .. "\n");
      end;
    self.channel.output:writeString("\n");
  end,
  'reset', function(self) 
    self.buffer = haxe.io.BytesBuffer.new();
  end,
  'write', function(self,data) 
    local _this = self.buffer;
    local len = data.length;
    if ((len < 0) or (len > data.length)) then 
      _G.error(haxe.io.Error.OutsideBounds,0);
    end;
    local b1 = _this.b;
    local b2 = data.b;
    local _g1 = 0;
    local _g = len;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      _this.b:push(b2[i]);
      end;
  end,
  'writeString', function(self,data) 
    local _this = self.buffer;
    local src = haxe.io.Bytes.ofString(data);
    local b1 = _this.b;
    local b2 = src.b;
    local _g1 = 0;
    local _g = src.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      _this.b:push(b2[i]);
      end;
  end,
  'close', function(self) 
    local descr = http._HttpStatus.HttpStatus_Impl_.getDescription(self.status);
    self.channel.output:writeString("HTTP/1.1 " .. self.status .. " " .. descr .. "\n");
    self:writeHeaders();
    self.channel.output:write(self.buffer:getBytes());
  end
  ,'__class__',  http.HttpResponse
)
http.HttpResponse.__super__ = haxe.io.Output
setmetatable(http.HttpResponse.prototype,{__index=haxe.io.Output.prototype})

http._HttpStatus.HttpStatus_Impl_.new = {}
http._HttpStatus.HttpStatus_Impl_.__name__ = true
http._HttpStatus.HttpStatus_Impl_.getDescription = function(this1) 
  local this2 = this1;
  if (this2) == 200 then 
    do return "OK" end;
  elseif (this2) == 400 then 
    do return "Bad request" end;
  elseif (this2) == 404 then 
    do return "Not found" end;
  elseif (this2) == 500 then 
    do return "Internal error" end; end;
  do return "Unknown" end;
end
_hxClasses["http.HttpVersion"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Version_0_9","Version_1_0","Version_1_1","Version_2_0"},4)}
http.HttpVersion = _hxClasses["http.HttpVersion"];
http.HttpVersion.Version_0_9 = _hx_tab_array({[0]="Version_0_9",0,__enum__ = http.HttpVersion},2)

http.HttpVersion.Version_1_0 = _hx_tab_array({[0]="Version_1_0",1,__enum__ = http.HttpVersion},2)

http.HttpVersion.Version_1_1 = _hx_tab_array({[0]="Version_1_1",2,__enum__ = http.HttpVersion},2)

http.HttpVersion.Version_2_0 = _hx_tab_array({[0]="Version_2_0",3,__enum__ = http.HttpVersion},2)


http.handlers.Handler.new = {}
http.handlers.Handler.__name__ = true
http.handlers.Handler.prototype = _hx_a(
  'process', function(self,context) 
  end,
  'callNext', function(self,context) 
    if (self.Next ~= nil) then 
      self.Next:process(context);
    end;
  end
  ,'__class__',  http.handlers.Handler
)

http.handlers.ErrorHandler.new = function(call) 
  local self = _hx_new(http.handlers.ErrorHandler.prototype)
  http.handlers.ErrorHandler.super(self,call)
  return self
end
http.handlers.ErrorHandler.super = function(self,call) 
  self._onError = _hx_funcToField(call);
end
http.handlers.ErrorHandler.__name__ = true
http.handlers.ErrorHandler.prototype = _hx_a(
  'processError', function(self,c,err) 
    c.response:reset();
    c.response.status = err;
    if (self._onError ~= nil) then 
      local _hx_expected_result = {}
      local _hx_status, _hx_result = pcall(function() 
      
          self:_onError(c,err);
         return _hx_expected_result end)
       if not _hx_status then 
        local _hx_1 = _hx_result
        local e = _hx_1
        c.response:reset();
        c.response.status = 500;
       elseif _hx_result ~= _hx_expected_result then return _hx_result end;
    end;
    c.response:close();
  end,
  'process', function(self,context) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        self:callNext(context);
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      if( lua.Boot.__instanceof(_hx_1,Int) ) then 
        local e = _hx_1
        self:processError(context,e);
      else
      local e1 = _hx_1
      self:processError(context,500);
       end 
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end
  ,'__class__',  http.handlers.ErrorHandler
)
http.handlers.ErrorHandler.__super__ = http.handlers.Handler
setmetatable(http.handlers.ErrorHandler.prototype,{__index=http.handlers.Handler.prototype})

http.handlers.HttpHandler.new = function(call) 
  local self = _hx_new(http.handlers.HttpHandler.prototype)
  http.handlers.HttpHandler.super(self,call)
  return self
end
http.handlers.HttpHandler.super = function(self,call) 
  self._onRequest = _hx_funcToField(call);
end
http.handlers.HttpHandler.__name__ = true
http.handlers.HttpHandler.prototype = _hx_a(
  'process', function(self,context) 
    if (self._onRequest ~= nil) then 
      self:_onRequest(context);
      context.response:close();
    end;
  end
  ,'__class__',  http.handlers.HttpHandler
)
http.handlers.HttpHandler.__super__ = http.handlers.Handler
setmetatable(http.handlers.HttpHandler.prototype,{__index=http.handlers.Handler.prototype})

http.handlers.StaticHandler.new = function() 
  local self = _hx_new(http.handlers.StaticHandler.prototype)
  http.handlers.StaticHandler.super(self)
  return self
end
http.handlers.StaticHandler.super = function(self) 
  self.paths = haxe.ds.StringMap.new();
end
http.handlers.StaticHandler.__name__ = true
http.handlers.StaticHandler.prototype = _hx_a(
  'addPath', function(self,path) 
    if (not tarantool.fio.Path.exists(path)) then 
      _G.error("Directory " .. path .. " not exists",0);
    end;
    local parts = path:split("/");
    local parts1 = parts:filter(function(s) 
      if ((s ~= "") and (s ~= ".")) then 
        do return s ~= ".." end;
      else
        do return false end;
      end;
    end);
    local newPath = parts1:join("/");
    local _this = self.paths;
    _this.v[newPath] = newPath;
    _this.k[newPath] = true;
  end,
  'process', function(self,context) 
    local path = context.request.url.path;
    local parts = path:split("/");
    local fileName = parts:pop();
    local parts1 = parts:filter(function(s) 
      if ((s ~= "") and (s ~= ".")) then 
        do return s ~= ".." end;
      else
        do return false end;
      end;
    end);
    local first = parts1[0];
    local newPath = parts1:join("/");
    local this1 = self.paths;
    if ((this1.k[first] or false)) then 
      local fl = "./" .. newPath .. "/" .. fileName;
      if (tarantool.fio.Path.exists(fl)) then 
        local mime1 = mime.MimeTypes.getMimeType(fileName);
        local _this = context.response.headers;
        local key = "Content-Type";
        _this.v[key] = mime1;
        _this.k[key] = true;
        local file = tarantool.fio.File.new(fl);
        local data = file:readAllBytes(fl);
        context.response:write(data);
        context.response:close();
      else
        _G.error(404,0);
      end;
    else
      self:callNext(context);
    end;
  end
  ,'__class__',  http.handlers.StaticHandler
)
http.handlers.StaticHandler.__super__ = http.handlers.Handler
setmetatable(http.handlers.StaticHandler.prototype,{__index=http.handlers.Handler.prototype})

http.handlers.websocket.FrameType.new = {}
http.handlers.websocket.FrameType.__name__ = true
_hxClasses["http.handlers.websocket.WorkState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="HANDSHAKE","FRAME_TYPE","LENGTH","DATA","CLOSE"},5)}
http.handlers.websocket.WorkState = _hxClasses["http.handlers.websocket.WorkState"];
http.handlers.websocket.WorkState.HANDSHAKE = _hx_tab_array({[0]="HANDSHAKE",0,__enum__ = http.handlers.websocket.WorkState},2)

http.handlers.websocket.WorkState.FRAME_TYPE = _hx_tab_array({[0]="FRAME_TYPE",1,__enum__ = http.handlers.websocket.WorkState},2)

http.handlers.websocket.WorkState.LENGTH = _hx_tab_array({[0]="LENGTH",2,__enum__ = http.handlers.websocket.WorkState},2)

http.handlers.websocket.WorkState.DATA = _hx_tab_array({[0]="DATA",3,__enum__ = http.handlers.websocket.WorkState},2)

http.handlers.websocket.WorkState.CLOSE = _hx_tab_array({[0]="CLOSE",4,__enum__ = http.handlers.websocket.WorkState},2)


http.handlers.websocket.InternalHandler.new = function(context) 
  local self = _hx_new(http.handlers.websocket.InternalHandler.prototype)
  http.handlers.websocket.InternalHandler.super(self,context)
  return self
end
http.handlers.websocket.InternalHandler.super = function(self,context) 
  self.channel = context.response.channel;
  self.headers = context.request.headers;
  self.state = http.handlers.websocket.WorkState.HANDSHAKE;
end
http.handlers.websocket.InternalHandler.__name__ = true
http.handlers.websocket.InternalHandler.prototype = _hx_a(
  'decode', function(self,str) 
    local base = haxe.io.Bytes.ofString("0123456789abcdef");
    do return haxe.crypto.BaseCode.new(base):decodeBytes(haxe.io.Bytes.ofString(str:toLowerCase())) end
  end,
  'pushError', function(self,e) 
    if (self.onError ~= nil) then 
      self:onError(self.peer,e);
    end;
  end,
  'processHandshake', function(self) 
    local this1 = self.headers;
    local key = this1.v["Sec-WebSocket-Key"] .. "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    local sha = haxe.crypto.Sha1.encode(key);
    local shaKey = haxe.crypto.Base64.encode(self:decode(sha));
    local stringBuffer_length;
    local stringBuffer_b = _hx_e();
    stringBuffer_length = 0;
    local str = "HTTP/1.1 101 Switching Protocols\r\n";
    _G.table.insert(stringBuffer_b,str);
    stringBuffer_length = stringBuffer_length + str.length;
    local str1 = "Upgrade: websocket\r\n";
    _G.table.insert(stringBuffer_b,str1);
    stringBuffer_length = stringBuffer_length + str1.length;
    local str2 = "Connection: Upgrade\r\n";
    _G.table.insert(stringBuffer_b,str2);
    stringBuffer_length = stringBuffer_length + str2.length;
    local str3 = Std.string("Sec-WebSocket-Accept: " .. shaKey .. "\r\n");
    _G.table.insert(stringBuffer_b,str3);
    stringBuffer_length = stringBuffer_length + str3.length;
    local str4 = "\r\n";
    _G.table.insert(stringBuffer_b,str4);
    stringBuffer_length = stringBuffer_length + str4.length;
    self.channel.output:writeString(_G.table.concat(stringBuffer_b));
    self.state = http.handlers.websocket.WorkState.FRAME_TYPE;
    self:onConnect(self.peer,self);
  end,
  'processFrame', function(self) 
    local binaryData = self.channel.input:read(2);
    local frame = binaryData.b[0];
    self.frameType = _hx_bit.band(frame,15);
    local len = binaryData.b[1];
    self.packLen = 0;
    if ((_hx_bit.band(len,128)) < 1) then 
      _G.error("Only masked message allowed",0);
    end;
    local tmp = self;
    tmp.packLen = tmp.packLen + (_hx_bit.bxor(len,128));
    if (self.packLen > 125) then 
      self.state = http.handlers.websocket.WorkState.LENGTH;
    else
      self.state = http.handlers.websocket.WorkState.DATA;
    end;
  end,
  'processLength', function(self) 
    if (self.packLen == 126) then 
      local binaryData = self.channel.input:read(2);
      local tmp = self;
      tmp.packLen = tmp.packLen + binaryData.b[0];
    else
      if (self.packLen ~= 127) then 
        _G.error("Wrong length type",0);
      end;
    end;
    self.state = http.handlers.websocket.WorkState.DATA;
  end,
  'processData', function(self) 
    local binaryData = self.channel.input:read(self.packLen + 4);
    local _g = self.frameType;
    local _g1 = _g;
    if (_g1) == 1 or (_g1) == 2 then 
      local mask = binaryData:sub(0,4);
      local data = binaryData:sub(4,binaryData.length - 4);
      local res = haxe.io.Bytes.alloc(data.length);
      local _g11 = 0;
      local _g2 = data.length;
      while (_g11 < _g2) do 
        _g11 = _g11 + 1;
        local i = _g11 - 1;
        local j = _G.math.fmod(i, 4);
        local b = data.b[i];
        local d = _hx_bit.bxor(b,mask.b[j]);
        res.b[i] = _hx_bit.band(d,255);
        end;
      self:onData(self.peer,res,self);
      self.state = http.handlers.websocket.WorkState.FRAME_TYPE;
    elseif (_g1) == 8 then 
      self:onClose(nil);
      self.state = http.handlers.websocket.WorkState.CLOSE;
      self:Disconnect();else
    _G.error("Unknown frame",0); end;
  end,
  'Disconnect', function(self) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        self.channel.output:close();
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      local e = _hx_1
      haxe.Log.trace(e,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="InternalHandler.hx",lineNumber=257,className="http.handlers.websocket.InternalHandler",methodName="Disconnect"}));
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'start', function(self) 
    local _hx_expected_result = {}
    local _hx_status, _hx_result = pcall(function() 
    
        local _hx_expected_result = {}
        local _hx_status, _hx_result = pcall(function() 
        
          while (true) do 
            local _g = self.state;
            local _g1 = _g[1];
            if (_g1) == 0 then 
              self:processHandshake();
            elseif (_g1) == 1 then 
              self:processFrame();
            elseif (_g1) == 2 then 
              self:processLength();
            elseif (_g1) == 3 then 
              self:processData();
            elseif (_g1) == 4 then 
              _G.error("_hx__break__"); end;
            
        end
         return _hx_expected_result end)
         if not _hx_status then 
         elseif _hx_result ~= _hx_expected_result then return _hx_result
        end;
       return _hx_expected_result end)
     if not _hx_status then 
      local _hx_1 = _hx_result
      local e = _hx_1
      self:pushError(e);
      self:Disconnect();
     elseif _hx_result ~= _hx_expected_result then return _hx_result end;
  end,
  'write', function(self,data) 
    local frame = haxe.io.Bytes.alloc(2 + data.length);
    frame.b[0] = 130;
    frame.b[1] = _hx_bit.band(data.length,255);
    frame:blit(2,data,0,data.length);
    self.channel.output:write(frame);
  end,
  'writeString', function(self,data) 
    local frame = haxe.io.Bytes.alloc(2 + data.length);
    frame.b[0] = 129;
    frame.b[1] = _hx_bit.band(data.length,255);
    local dat = haxe.io.Bytes.ofString(data);
    frame:blit(2,dat,0,dat.length);
    self.channel.output:write(frame);
  end,
  'close', function(self) 
    self.channel.output:close();
  end
  ,'__class__',  http.handlers.websocket.InternalHandler
)
http.handlers.websocket.InternalHandler.__super__ = haxe.io.Output
setmetatable(http.handlers.websocket.InternalHandler.prototype,{__index=haxe.io.Output.prototype})

http.handlers.websocket.WebSocketHandler.new = function(handler) 
  local self = _hx_new(http.handlers.websocket.WebSocketHandler.prototype)
  http.handlers.websocket.WebSocketHandler.super(self,handler)
  return self
end
http.handlers.websocket.WebSocketHandler.super = function(self,handler) 
  self._handler = handler;
end
http.handlers.websocket.WebSocketHandler.__name__ = true
http.handlers.websocket.WebSocketHandler.prototype = _hx_a(
  'process', function(self,context) 
    local this1 = context.request.headers;
    if ((this1.k["Upgrade"] or false)) then 
      local ih = http.handlers.websocket.InternalHandler.new(context);
      ih.onConnect = _hx_funcToField((function() local __=self._handler; return _hx_bind(__,__.onConnect) end)());
      ih.onData = _hx_funcToField((function() local __=self._handler; return _hx_bind(__,__.onData) end)());
      ih.onClose = _hx_funcToField((function() local __=self._handler; return _hx_bind(__,__.onClose) end)());
      ih.onError = _hx_funcToField((function() local __=self._handler; return _hx_bind(__,__.onError) end)());
      ih:start();
    else
      self:callNext(context);
    end;
  end
  ,'__class__',  http.handlers.websocket.WebSocketHandler
)
http.handlers.websocket.WebSocketHandler.__super__ = http.handlers.Handler
setmetatable(http.handlers.websocket.WebSocketHandler.prototype,{__index=http.handlers.Handler.prototype})

lua.Boot.new = {}
lua.Boot.__name__ = true
lua.Boot.getClass = function(o) 
  if (lua.Boot.__instanceof(o,Array)) then 
    do return Array end;
  else
    local cl = o.__class__;
    if (cl ~= nil) then 
      do return cl end;
    else
      do return nil end;
    end;
  end;
end
lua.Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return lua.Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return true end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == lua.Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == lua.UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    if (lua.Boot.extendsOrImplements(lua.Boot.getClass(o),cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_1
      if (cl == Class) then 
      _hx_1 = o.__name__ ~= nil; else 
      _hx_1 = false; end
      return _hx_1
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Enum) then 
      _hx_2 = o.__ename__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.__cast = function(o,t) 
  if (lua.Boot.__instanceof(o,t)) then 
    do return o end;
  else
    _G.error("Cannot cast " .. Std.string(o) .. " to " .. Std.string(t),0);
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g1 = 1;
        local _g = _hx_table.maxn(intf) + 1;
        while (_g1 < _g) do 
          _g1 = _g1 + 1;
          local i = _g1 - 1;
          if (lua.Boot.extendsOrImplements(intf[i],cl2)) then 
            do return true end;
          end;
          end;
      end;
    end;
  end;
  do return lua.Boot.extendsOrImplements(cl1.__super__,cl2) end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function() 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function() 
    do return cur_val ~= nil end;
  end}) end;
end

lua.UserData.new = {}
lua.UserData.__name__ = true

lua.Thread.new = {}
lua.Thread.__name__ = true
lua.lib.luasocket = {}
lua.lib.luasocket.Socket = _G.require("socket")

mime.MimeTypes.new = {}
mime.MimeTypes.__name__ = true
mime.MimeTypes.getMimeType = function(path) 
  local lind = path:lastIndexOf(".");
  local ext;
  if (lind < 0) then 
    ext = "";
  else
    lind = lind + 1;
    ext = path:substr(lind,path.length - lind);
  end;
  local this1 = mime.MimeTypes.mimeTypes;
  local res = this1.v[ext];
  if (res ~= nil) then 
    do return res end;
  else
    do return "application/octet-stream" end;
  end;
end

tarantool.fio.File.new = function(path) 
  local self = _hx_new(tarantool.fio.File.prototype)
  tarantool.fio.File.super(self,path)
  return self
end
tarantool.fio.File.super = function(self,path) 
  self.file = tarantool.fio.native.NativeFio.open(path);
end
tarantool.fio.File.__name__ = true
tarantool.fio.File.getExtension = function(path) 
  local lind = path:lastIndexOf(".");
  if (lind < 0) then 
    do return "" end;
  end;
  lind = lind + 1;
  do return path:substr(lind,path.length - lind) end;
end
tarantool.fio.File.prototype = _hx_a(
  'readAllBytes', function(self,path) 
    local s = self.file:stat();
    local size = s.size;
    local data = self.file:read(size);
    self.file:close();
    do return haxe.io.Bytes.ofString(data) end
  end
  ,'__class__',  tarantool.fio.File
)

tarantool.fio.Path.new = {}
tarantool.fio.Path.__name__ = true
tarantool.fio.Path.readDirectory = function(path) 
  local dat = tarantool.fio.native.NativeFio.glob(path);
  local res = _hx_tab_array({ }, 0);
  _G.table.foreach(dat,function(e,i) 
    res:push(i);
  end);
  do return res end;
end
tarantool.fio.Path.exists = function(path) 
  local d = tarantool.fio.native.NativeFio.stat(path);
  do return d ~= nil end;
end
tarantool.fio.native = {}
tarantool.fio.native.NativeFio = _G.require("fio")

tarantool.socket.Peer.new = function(host,port) 
  local self = _hx_new(tarantool.socket.Peer.prototype)
  tarantool.socket.Peer.super(self,host,port)
  return self
end
tarantool.socket.Peer.super = function(self,host,port) 
  self.host = host;
  self.port = port;
end
tarantool.socket.Peer.__name__ = true
tarantool.socket.Peer.prototype = _hx_a(
  
  '__class__',  tarantool.socket.Peer
)
_hxClasses["tarantool.socket.SocketError"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Disconnect"},1)}
tarantool.socket.SocketError = _hxClasses["tarantool.socket.SocketError"];
tarantool.socket.SocketError.Disconnect = _hx_tab_array({[0]="Disconnect",0,__enum__ = tarantool.socket.SocketError},2)


tarantool.socket.SocketInput.new = function(s) 
  local self = _hx_new(tarantool.socket.SocketInput.prototype)
  tarantool.socket.SocketInput.super(self,s)
  return self
end
tarantool.socket.SocketInput.super = function(self,s) 
  self.sock = s;
end
tarantool.socket.SocketInput.__name__ = true
tarantool.socket.SocketInput.prototype = _hx_a(
  'readByte', function(self) 
    local dat = self.sock:read(1);
    if ((dat == nil) or (dat.length < 1)) then 
      _G.error(tarantool.socket.SocketError.Disconnect,0);
    end;
    local cur_idx = 0;
    local pos = 0;
    local _g1 = 0;
    local _g = 0;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      pos = pos + haxe.Utf8.charWidth(dat:charCodeAt(pos));
      end;
    local ret = 0;
    local code = dat:charCodeAt(pos);
    local bytes = haxe.Utf8.charWidth(code);
    if (bytes == 1) then 
      do return code end;
    else
      if (bytes == 2) then 
        do return _hx_bit.bor(_hx_bit.lshift((_hx_bit.band(code,63)),6),_hx_bit.band(dat:charCodeAt(pos + 1),127)) end;
      else
        if (bytes == 3) then 
          do return _hx_bit.bor(_hx_bit.bor(_hx_bit.lshift((_hx_bit.band(code,31)),12),_hx_bit.lshift((_hx_bit.band(dat:charCodeAt(pos + 1),127)),6)),_hx_bit.band(dat:charCodeAt(pos + 2),127)) end;
        else
          do return _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_hx_bit.lshift((_hx_bit.band(code,15)),18),_hx_bit.lshift((_hx_bit.band(dat:charCodeAt(pos + 1),127)),12)),_hx_bit.lshift((_hx_bit.band(dat:charCodeAt(pos + 2),127)),6)),_hx_bit.band(dat:charCodeAt(pos + 3),127)) end;
        end;
      end;
    end;
  end,
  'readBytes', function(self,s,pos,len) 
    local dat = self.sock:read(len);
    if ((dat == nil) or (dat.length < 1)) then 
      _G.error(tarantool.socket.SocketError.Disconnect,0);
    end;
    local b = haxe.io.Bytes.ofString(dat);
    s:blit(pos,b,0,b.length);
    do return dat.length end
  end,
  'readLine', function(self) 
    local dat = self.sock:read("\n");
    if ((dat == nil) or (dat.length < 1)) then 
      _G.error(tarantool.socket.SocketError.Disconnect,0);
    end;
    do return dat end
  end
  ,'__class__',  tarantool.socket.SocketInput
)
tarantool.socket.SocketInput.__super__ = haxe.io.Input
setmetatable(tarantool.socket.SocketInput.prototype,{__index=haxe.io.Input.prototype})

tarantool.socket.SocketOutput.new = function(s) 
  local self = _hx_new(tarantool.socket.SocketOutput.prototype)
  tarantool.socket.SocketOutput.super(self,s)
  return self
end
tarantool.socket.SocketOutput.super = function(self,s) 
  self._sock = s;
end
tarantool.socket.SocketOutput.__name__ = true
tarantool.socket.SocketOutput.prototype = _hx_a(
  'writeByte', function(self,c) 
    local s = haxe.Utf8.char(c);
    self._sock:write(s);
  end,
  'writeString', function(self,s) 
    self._sock:write(s);
  end,
  'writeBytes', function(self,s,pos,len) 
    local str = s:getString(pos,len);
    do return self._sock:write(str) end
  end
  ,'__class__',  tarantool.socket.SocketOutput
)
tarantool.socket.SocketOutput.__super__ = haxe.io.Output
setmetatable(tarantool.socket.SocketOutput.prototype,{__index=haxe.io.Output.prototype})
tarantool.socket.native = {}
tarantool.socket.native.NativeSocket = _G.require("socket")

tink._Stringly.Stringly_Impl_.new = {}
tink._Stringly.Stringly_Impl_.__name__ = true
tink._Stringly.Stringly_Impl_.isNumber = function(s,allowFloat) 
  if (s.length == 0) then 
    do return false end;
  end;
  local pos = 0;
  local max = s.length;
  if ((pos < max) and (_G.string.byte(s,pos + 1) == 45)) then 
    pos = pos + 1;
  end;
  if (not allowFloat) then 
    local tmp;
    if ((pos < max) and (_G.string.byte(s,pos + 1) == 48)) then 
      pos = pos + 1;
      tmp = (pos - 1) > -1;
    else
      tmp = false;
    end;
    if (tmp) then 
      if ((pos < max) and (_G.string.byte(s,pos + 1) == 120)) then 
        pos = pos + 1;
      end;
    end;
  end;
  while ((pos < max) and ((_hx_bit.bxor(_G.string.byte(s,pos + 1),48)) < 10)) do 
    pos = pos + 1;
    end;
  if (allowFloat and (pos < max)) then 
    local tmp1;
    if ((pos < max) and (_G.string.byte(s,pos + 1) == 46)) then 
      pos = pos + 1;
      tmp1 = (pos - 1) > -1;
    else
      tmp1 = false;
    end;
    if (tmp1) then 
      while ((pos < max) and ((_hx_bit.bxor(_G.string.byte(s,pos + 1),48)) < 10)) do 
        pos = pos + 1;
        end;
    end;
    local tmp2;
    local tmp3;
    if ((pos < max) and (_G.string.byte(s,pos + 1) == 101)) then 
      pos = pos + 1;
      tmp3 = (pos - 1) > -1;
    else
      tmp3 = false;
    end;
    if (not tmp3) then 
      if ((pos < max) and (_G.string.byte(s,pos + 1) == 69)) then 
        pos = pos + 1;
        tmp2 = (pos - 1) > -1;
      else
        tmp2 = false;
      end;
    else
      tmp2 = true;
    end;
    if (tmp2) then 
      local tmp4;
      if ((pos < max) and (_G.string.byte(s,pos + 1) == 43)) then 
        pos = pos + 1;
        tmp4 = (pos - 1) > -1;
      else
        tmp4 = false;
      end;
      if (not tmp4) then 
        if ((pos < max) and (_G.string.byte(s,pos + 1) == 45)) then 
          pos = pos + 1;
        end;
      end;
      while ((pos < max) and ((_hx_bit.bxor(_G.string.byte(s,pos + 1),48)) < 10)) do 
        pos = pos + 1;
        end;
    end;
  end;
  do return pos == max end;
end
tink._Stringly.Stringly_Impl_.toBool = function(this1) 
  if (this1 ~= nil) then 
    local _g = StringTools.trim(this1):toLowerCase();
    local _g1 = _g;
    if (_g1) == "0" or (_g1) == "false" or (_g1) == "no" then 
      do return false end;else
    do return true end; end;
  else
    do return false end;
  end;
end
tink._Stringly.Stringly_Impl_.parseFloat = function(this1) 
  local _g = StringTools.trim(this1);
  local v = _g;
  if (tink._Stringly.Stringly_Impl_.isNumber(v,true)) then 
    do return tink.core.Outcome.Success(Std.parseFloat(v)) end;
  else
    local v1 = _g;
    do return tink.core.Outcome.Failure(tink.core.TypedError.new(422,"" .. v1 .. " (encoded as " .. this1 .. ") is not a valid float",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Stringly.hx",lineNumber=60,className="tink._Stringly.Stringly_Impl_",methodName="parseFloat"}))) end;
  end;
end
tink._Stringly.Stringly_Impl_.toFloat = function(this1) 
  do return tink.core.OutcomeTools.sure(tink._Stringly.Stringly_Impl_.parseFloat(this1)) end;
end
tink._Stringly.Stringly_Impl_.parseInt = function(this1) 
  local _g = StringTools.trim(this1);
  local v = _g;
  if (tink._Stringly.Stringly_Impl_.isNumber(v,false)) then 
    do return tink.core.Outcome.Success(Std.parseInt(v)) end;
  else
    local v1 = _g;
    do return tink.core.Outcome.Failure(tink.core.TypedError.new(422,"" .. v1 .. " (encoded as " .. this1 .. ") is not a valid integer",_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Stringly.hx",lineNumber=71,className="tink._Stringly.Stringly_Impl_",methodName="parseInt"}))) end;
  end;
end
tink._Stringly.Stringly_Impl_.toInt = function(this1) 
  do return tink.core.OutcomeTools.sure(tink._Stringly.Stringly_Impl_.parseInt(this1)) end;
end
tink._Stringly.Stringly_Impl_.ofBool = function(b) 
  if (b) then 
    do return "true" end;
  else
    do return "false" end;
  end;
end
tink._Stringly.Stringly_Impl_.ofInt = function(i) 
  do return Std.string(i) end;
end
tink._Stringly.Stringly_Impl_.ofFloat = function(f) 
  do return Std.string(f) end;
end

tink._Url.Url_Impl_.new = {}
tink._Url.Url_Impl_.__name__ = true
tink._Url.Url_Impl_._new = function(parts) 
  local this1 = parts;
  do return this1 end;
end
tink._Url.Url_Impl_.resolve = function(this1,that) 
  if (that.scheme ~= nil) then 
    do return that end;
  else
    if (that.host ~= nil) then 
      if (that.scheme ~= nil) then 
        do return that end;
      else
        local copy = Reflect.copy(that);
        copy.scheme = this1.scheme;
        do return copy end;
      end;
    else
      local parts = _hx_o({__fields__={path=true,payload=true,scheme=true,query=true,auth=true,host=true,hash=true},path=tink.url._Path.Path_Impl_.join(this1.path,that.path),payload="",scheme=this1.scheme,query=that.query,auth=this1.auth,host=this1.host,hash=that.hash});
      tink._Url.Url_Impl_.makePayload(parts);
      local this2 = parts;
      do return this2 end;
    end;
  end;
end
tink._Url.Url_Impl_.makePayload = function(parts) 
  local payload = "";
  if (parts.auth == nil) then 
    if (parts.host ~= nil) then 
      local host = parts.host;
      payload = payload .. ("//" .. host);
    end;
  else
    if (parts.host == nil) then 
      local auth = parts.auth;
      payload = payload .. ("//" .. auth .. "@");
    else
      local auth1 = parts.auth;
      local host1 = parts.host;
      payload = payload .. ("//" .. auth1 .. "@" .. host1);
    end;
  end;
  payload = payload .. parts.path;
  local _g = parts.query;
  if (_g ~= nil) then 
    local v = _g;
    payload = payload .. ("?" .. v);
  end;
  local _g1 = parts.hash;
  if (_g1 ~= nil) then 
    local v1 = _g1;
    payload = payload .. ("#" .. v1);
  end;
  parts.payload = payload:toString();
end
tink._Url.Url_Impl_.toString = function(this1) 
  local _g = this1.scheme;
  if (_g == nil) then 
    do return this1.payload end;
  else
    do return "" .. this1.scheme .. ":" .. this1.payload end;
  end;
end
tink._Url.Url_Impl_.parse = function(s) 
  if (s == nil) then 
    do return tink._Url.Url_Impl_.parse("") end;
  end;
  s = StringTools.trim(s);
  if (StringTools.startsWith(s,"data:")) then 
    local this1 = _hx_o({__fields__={scheme=true,payload=true},scheme="data",payload=s:substr(5)});
    do return this1 end;
  end;
  local FORMAT = EReg.new("^(([a-zA-Z][a-zA-Z0-9\\-]*):)?((//(([^@/]+)@)?([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?)$","");
  local HOST = EReg.new("^(\\[(.*)\\]|([^:]*))(:(\\d*))?$","");
  FORMAT:match(s);
  local hosts;
  local _g = FORMAT:matched(7);
  if (_g == nil) then 
    hosts = _hx_tab_array({ }, 0);
  else
    local v = _g;
    local _g1 = _hx_tab_array({ }, 0);
    local _g11 = 0;
    local _g2 = v:split(",");
    while (_g11 < _g2.length) do 
      local host = _g2[_g11];
      _g11 = _g11 + 1;
      HOST:match(host);
      local host1;
      local _g3 = HOST:matched(2);
      local _g4 = HOST:matched(3);
      if (_g3 == nil) then 
        local ipv4 = _g4;
        host1 = ipv4;
      else
        if (_g4 == nil) then 
          local ipv6 = _g3;
          host1 = "[" .. ipv6 .. "]";
        else
          _G.error("assert",0);
        end;
      end;
      local port;
      local _g5 = HOST:matched(5);
      if (_g5 == nil) then 
        port = nil;
      else
        local v1 = _g5;
        local _g51 = Std.parseInt(v1);
        if (_g51 == nil) then 
          _G.error("Invalid port",0);
        else
          local p = _g51;
          port = p;
        end;
      end;
      local this2;
      if (port == nil) then 
        this2 = host1;
      else
        if ((port > 65535) or (port <= 0)) then 
          _G.error("Invalid port",0);
        else
          this2 = "" .. host1 .. ":" .. port;
        end;
      end;
      _g1:push(this2);
      end;
    hosts = _g1;
  end;
  local path = FORMAT:matched(8);
  if ((hosts.length > 0) and (path:charAt(0) ~= "/")) then 
    path = "/" .. path;
  end;
  local this3 = _hx_o({__fields__={scheme=true,payload=true,host=true,hosts=true,auth=true,path=true,query=true,hash=true},scheme=FORMAT:matched(2),payload=FORMAT:matched(3),host=hosts[0],hosts=hosts,auth=FORMAT:matched(6),path=tink.url._Path.Path_Impl_.ofString(path),query=FORMAT:matched(10),hash=FORMAT:matched(12)});
  do return this3 end;
end

tink.core._Any.Any_Impl_.new = {}
tink.core._Any.Any_Impl_.__name__ = true
tink.core._Any.Any_Impl_.__promote = function(this1) 
  do return this1 end;
end

tink.core._Callback.Callback_Impl_.new = {}
tink.core._Callback.Callback_Impl_.__name__ = true
tink.core._Callback.Callback_Impl_._new = function(f) 
  local this1 = f;
  do return this1 end;
end
tink.core._Callback.Callback_Impl_.toFunction = function(this1) 
  do return this1 end;
end
tink.core._Callback.Callback_Impl_.invoke = function(this1,data) 
  this1(data);
end
tink.core._Callback.Callback_Impl_.ignore = function(cb) 
  do return tink.core._Callback.Callback_Impl_.fromNiladic(function() 
    cb(tink.core.Noise.Noise);
  end) end;
end
tink.core._Callback.Callback_Impl_.fromNiladic = function(f) 
  local this1 = function(r) 
    f();
  end;
  do return this1 end;
end
tink.core._Callback.Callback_Impl_.fromMany = function(callbacks) 
  do return function(v) 
    local _g = 0;
    while (_g < callbacks.length) do 
      local callback = callbacks[_g];
      _g = _g + 1;
      callback(v);
      end;
  end end;
end
tink.core._Callback.Callback_Impl_.defer = function(f) 
  haxe.Timer.delay(f,0);
end

tink.core._Callback.LinkObject.new = {}
tink.core._Callback.LinkObject.__name__ = true
tink.core._Callback.LinkObject.prototype = _hx_a(
  
  '__class__',  tink.core._Callback.LinkObject
)

tink.core._Callback.CallbackLink_Impl_.new = {}
tink.core._Callback.CallbackLink_Impl_.__name__ = true
tink.core._Callback.CallbackLink_Impl_._new = function(link) 
  local this1 = tink.core._Callback.SimpleLink.new(link);
  do return this1 end;
end
tink.core._Callback.CallbackLink_Impl_.dissolve = function(this1) 
  if (this1 ~= nil) then 
    this1:dissolve();
  end;
end
tink.core._Callback.CallbackLink_Impl_.toCallback = function(this1) 
  do return function(_) 
    this1:dissolve();
  end end;
end
tink.core._Callback.CallbackLink_Impl_.fromFunction = function(f) 
  local this1 = tink.core._Callback.SimpleLink.new(f);
  do return this1 end;
end
tink.core._Callback.CallbackLink_Impl_.join = function(a,b) 
  do return tink.core._Callback.LinkPair.new(a,b) end;
end
tink.core._Callback.CallbackLink_Impl_.fromMany = function(callbacks) 
  local this1 = tink.core._Callback.SimpleLink.new(function() 
    local _g = 0;
    while (_g < callbacks.length) do 
      local cb = callbacks[_g];
      _g = _g + 1;
      if (cb ~= nil) then 
        cb:dissolve();
      end;
      end;
  end);
  do return this1 end;
end

tink.core._Callback.SimpleLink.new = function(f) 
  local self = _hx_new(tink.core._Callback.SimpleLink.prototype)
  tink.core._Callback.SimpleLink.super(self,f)
  return self
end
tink.core._Callback.SimpleLink.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
tink.core._Callback.SimpleLink.__name__ = true
tink.core._Callback.SimpleLink.__interfaces__ = {tink.core._Callback.LinkObject}
tink.core._Callback.SimpleLink.prototype = _hx_a(
  'dissolve', function(self) 
    if (self.f ~= nil) then 
      self:f();
    end;
  end
  ,'__class__',  tink.core._Callback.SimpleLink
)

tink.core._Callback.LinkPair.new = function(a,b) 
  local self = _hx_new(tink.core._Callback.LinkPair.prototype)
  tink.core._Callback.LinkPair.super(self,a,b)
  return self
end
tink.core._Callback.LinkPair.super = function(self,a,b) 
  self.dissolved = false;
  self.a = a;
  self.b = b;
end
tink.core._Callback.LinkPair.__name__ = true
tink.core._Callback.LinkPair.__interfaces__ = {tink.core._Callback.LinkObject}
tink.core._Callback.LinkPair.prototype = _hx_a(
  'dissolve', function(self) 
    if (not self.dissolved) then 
      self.dissolved = true;
      local this1 = self.a;
      if (this1 ~= nil) then 
        this1:dissolve();
      end;
      local this2 = self.b;
      if (this2 ~= nil) then 
        this2:dissolve();
      end;
    end;
  end
  ,'__class__',  tink.core._Callback.LinkPair
)

tink.core._Callback.ListCell.new = function(cb,list) 
  local self = _hx_new(tink.core._Callback.ListCell.prototype)
  tink.core._Callback.ListCell.super(self,cb,list)
  return self
end
tink.core._Callback.ListCell.super = function(self,cb,list) 
  if (cb == nil) then 
    _G.error("callback expected but null received",0);
  end;
  self.cb = cb;
  self.list = list;
end
tink.core._Callback.ListCell.__name__ = true
tink.core._Callback.ListCell.__interfaces__ = {tink.core._Callback.LinkObject}
tink.core._Callback.ListCell.prototype = _hx_a(
  'invoke', function(self,data) 
    if (self.cb ~= nil) then 
      self.cb(data);
    end;
  end,
  'clear', function(self) 
    self.list = nil;
    self.cb = nil;
  end,
  'dissolve', function(self) 
    local _g = self.list;
    if (_g ~= nil) then 
      local v = _g;
      self:clear();
      v:remove(self);
    end;
  end
  ,'__class__',  tink.core._Callback.ListCell
)

tink.core._Callback.CallbackList_Impl_.new = {}
tink.core._Callback.CallbackList_Impl_.__name__ = true
tink.core._Callback.CallbackList_Impl_._new = function() 
  local this1 = _hx_tab_array({ }, 0);
  do return this1 end;
end
tink.core._Callback.CallbackList_Impl_.get_length = function(this1) 
  do return this1.length end;
end
tink.core._Callback.CallbackList_Impl_.add = function(this1,cb) 
  local node = tink.core._Callback.ListCell.new(cb,this1);
  this1:push(node);
  do return node end;
end
tink.core._Callback.CallbackList_Impl_.invoke = function(this1,data) 
  local _g = 0;
  local _g1 = _hx_tab_array({ }, 0);
  local _g11 = 0;
  local _g2 = this1;
  while (_g11 < _g2.length) do 
    local i = _g2[_g11];
    _g11 = _g11 + 1;
    _g1:push(i);
    end;
  local _g12 = _g1;
  while (_g < _g12.length) do 
    local cell = _g12[_g];
    _g = _g + 1;
    if (cell.cb ~= nil) then 
      cell.cb(data);
    end;
    end;
end
tink.core._Callback.CallbackList_Impl_.clear = function(this1) 
  local _g = 0;
  local _g1 = this1:splice(0,this1.length);
  while (_g < _g1.length) do 
    local cell = _g1[_g];
    _g = _g + 1;
    cell:clear();
    end;
end

tink.core.TypedError.new = function(code,message,pos) 
  local self = _hx_new(tink.core.TypedError.prototype)
  tink.core.TypedError.super(self,code,message,pos)
  return self
end
tink.core.TypedError.super = function(self,code,message,pos) 
  if (code == nil) then 
    code = 500;
  end;
  self.code = code;
  self.message = message;
  self.pos = pos;
  self.exceptionStack = _hx_tab_array({ }, 0);
  self.callStack = _hx_tab_array({ }, 0);
end
tink.core.TypedError.__name__ = true
tink.core.TypedError.withData = function(code,message,data,pos) 
  do return tink.core.TypedError.typed(code,message,data,pos) end;
end
tink.core.TypedError.typed = function(code,message,data,pos) 
  local ret = tink.core.TypedError.new(code,message,pos);
  ret.data = data;
  do return ret end;
end
tink.core.TypedError.catchExceptions = function(f,report,pos) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      do return tink.core.Outcome.Success(f()) end;
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    if( lua.Boot.__instanceof(_hx_1,tink.core.TypedError) ) then 
      local e = _hx_1
      do return tink.core.Outcome.Failure(e) end;
    else
    local e1 = _hx_1
    do return tink.core.Outcome.Failure((function() 
      local _hx_2
      if (report == nil) then 
      _hx_2 = tink.core.TypedError.withData(nil,"Unexpected Error",e1,pos); else 
      _hx_2 = report(e1); end
      return _hx_2
    end )()) end;
     end 
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end
tink.core.TypedError.reporter = function(code,message,pos) 
  do return function(e) 
    do return tink.core.TypedError.withData(code,message,e,pos) end;
  end end;
end
tink.core.TypedError.rethrow = function(any) 
  _G.error(any,0);
end
tink.core.TypedError.prototype = _hx_a(
  'printPos', function(self) 
    do return self.pos.className .. "." .. self.pos.methodName .. ":" .. self.pos.lineNumber end
  end,
  'toString', function(self) 
    local ret = "Error#" .. self.code .. ": " .. self.message;
    if (self.pos ~= nil) then 
      ret = ret .. (" @ " .. self:printPos());
    end;
    do return ret end
  end,
  'throwSelf', function(self) 
    _G.error(self,0);
  end
  ,'__class__',  tink.core.TypedError
)

tink.core._Error.Stack_Impl_.new = {}
tink.core._Error.Stack_Impl_.__name__ = true
tink.core._Error.Stack_Impl_.toString = function(this1) 
  do return haxe.CallStack.toString(this1) end;
end

tink.core._Future.Future_Impl_.new = {}
tink.core._Future.Future_Impl_.__name__ = true
tink.core._Future.Future_Impl_._new = function(f) 
  local this1 = tink.core._Future.SimpleFuture.new(f);
  do return this1 end;
end
tink.core._Future.Future_Impl_.handle = function(this1,callback) 
  do return this1:handle(callback) end;
end
tink.core._Future.Future_Impl_.eager = function(this1) 
  do return this1:eager() end;
end
tink.core._Future.Future_Impl_.gather = function(this1) 
  do return this1:gather() end;
end
tink.core._Future.Future_Impl_.first = function(this1,other) 
  local ret = tink.core.FutureTrigger.new();
  local l1 = this1:handle(_hx_bind(ret,ret.trigger));
  local l2 = other:handle(_hx_bind(ret,ret.trigger));
  local ret1 = ret;
  if (l1 ~= nil) then 
    local this2 = l1;
    ret1:handle(function(_) 
      this2:dissolve();
    end);
  end;
  if (l2 ~= nil) then 
    local this3 = l2;
    ret1:handle(function(_1) 
      this3:dissolve();
    end);
  end;
  do return ret1 end;
end
tink.core._Future.Future_Impl_.map = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local ret = this1:map(f);
  if (gather) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
tink.core._Future.Future_Impl_.flatMap = function(this1,next,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local ret = this1:flatMap(next);
  if (gather) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
tink.core._Future.Future_Impl_.merge = function(this1,other,merger,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local ret = this1:flatMap(function(t) 
    local ret1 = other:map(function(a) 
      do return merger(t,a) end;
    end);
    do return ret1 end;
  end);
  if (gather) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
tink.core._Future.Future_Impl_.flatten = function(f) 
  do return tink.core._Future.NestedFuture.new(f) end;
end
tink.core._Future.Future_Impl_.asPromise = function(s) 
  do return s end;
end
tink.core._Future.Future_Impl_.ofMany = function(futures,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local ret = tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(_hx_tab_array({ }, 0)));
  local _g = 0;
  while (_g < futures.length) do 
    local f = _hx_tab_array({[0]=futures[_g] }, 1);
    _g = _g + 1;
    local ret1 = ret:flatMap((function(f1) 
      do return function(results) 
        local ret2 = (function() 
          do return function(result) 
            do return results:concat(_hx_tab_array({[0]=result }, 1)) end;
          end end;
        end)();
        local ret3 = f1[0]:map(ret2);
        do return ret3 end;
      end end;
    end)(f));
    ret = ret1;
    end;
  if (gather) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
tink.core._Future.Future_Impl_.fromMany = function(futures) 
  do return tink.core._Future.Future_Impl_.ofMany(futures) end;
end
tink.core._Future.Future_Impl_.lazy = function(l) 
  do return tink.core._Future.SyncFuture.new(l) end;
end
tink.core._Future.Future_Impl_.sync = function(v) 
  do return tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(v)) end;
end
tink.core._Future.Future_Impl_.async = function(f,lazy) 
  if (lazy == nil) then 
    lazy = false;
  end;
  if (lazy) then 
    local f1 = f;
    do return tink.core._Future.Future_Impl_.flatten(tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyFunc.new(function() 
      do return tink.core._Future.Future_Impl_.async(f1,false) end;
    end))) end;
  else
    local op = tink.core.FutureTrigger.new();
    f(_hx_bind(op,op.trigger));
    do return op end;
  end;
end
tink.core._Future.Future_Impl_["or"] = function(a,b) 
  do return tink.core._Future.Future_Impl_.first(a,b) end;
end
tink.core._Future.Future_Impl_.either = function(a,b) 
  local ret = a:map(haxe.ds.Either.Left);
  local ret1 = b:map(haxe.ds.Either.Right);
  do return tink.core._Future.Future_Impl_.first(ret,ret1) end;
end
tink.core._Future.Future_Impl_["and"] = function(a,b) 
  do return tink.core._Future.Future_Impl_.merge(a,b,function(a1,b1) 
    local this1 = tink.core.MPair.new(a1,b1);
    do return this1 end;
  end) end;
end
tink.core._Future.Future_Impl_._tryFailingFlatMap = function(f,map) 
  local ret = f:flatMap(function(o) 
    local o1 = o[1];
    if (o1) == 0 then 
      local d = o[2];
      do return map(d) end;
    elseif (o1) == 1 then 
      local f1 = o[2];
      do return tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(tink.core.Outcome.Failure(f1))) end; end;
  end);
  do return ret:gather() end;
end
tink.core._Future.Future_Impl_._tryFlatMap = function(f,map) 
  local ret = f:flatMap(function(o) 
    local o1 = o[1];
    if (o1) == 0 then 
      local d = o[2];
      local ret1 = map(d):map(tink.core.Outcome.Success);
      do return ret1:gather() end;
    elseif (o1) == 1 then 
      local f1 = o[2];
      do return tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(tink.core.Outcome.Failure(f1))) end; end;
  end);
  do return ret:gather() end;
end
tink.core._Future.Future_Impl_._tryFailingMap = function(f,map) 
  local ret = f:map(function(o) 
    do return tink.core.OutcomeTools.flatMap(o,tink.core._Outcome.OutcomeMapper_Impl_.withSameError(map)) end;
  end);
  do return ret:gather() end;
end
tink.core._Future.Future_Impl_._tryMap = function(f,map) 
  local ret = f:map(function(o) 
    do return tink.core.OutcomeTools.map(o,map) end;
  end);
  do return ret:gather() end;
end
tink.core._Future.Future_Impl_._flatMap = function(f,map) 
  local ret = f:flatMap(map);
  do return ret:gather() end;
end
tink.core._Future.Future_Impl_._map = function(f,map) 
  local ret = f:map(map);
  do return ret:gather() end;
end
tink.core._Future.Future_Impl_.trigger = function() 
  do return tink.core.FutureTrigger.new() end;
end

tink.core._Future.FutureObject.new = {}
tink.core._Future.FutureObject.__name__ = true
tink.core._Future.FutureObject.prototype = _hx_a(
  
  '__class__',  tink.core._Future.FutureObject
)

tink.core._Future.SyncFuture.new = function(value) 
  local self = _hx_new(tink.core._Future.SyncFuture.prototype)
  tink.core._Future.SyncFuture.super(self,value)
  return self
end
tink.core._Future.SyncFuture.super = function(self,value) 
  self.value = value;
end
tink.core._Future.SyncFuture.__name__ = true
tink.core._Future.SyncFuture.__interfaces__ = {tink.core._Future.FutureObject}
tink.core._Future.SyncFuture.prototype = _hx_a(
  'map', function(self,f) 
    do return tink.core._Future.SyncFuture.new(self.value:map(f)) end
  end,
  'flatMap', function(self,f) 
    do return tink.core._Future.LazyFuture.new(self.value:map(f)) end
  end,
  'handle', function(self,cb) 
    cb(self.value:get());
    do return nil end
  end,
  'eager', function(self) 
    do return self end
  end,
  'gather', function(self) 
    do return self end
  end
  ,'__class__',  tink.core._Future.SyncFuture
)

tink.core._Future.LazyFuture.new = function(l) 
  local self = _hx_new(tink.core._Future.LazyFuture.prototype)
  tink.core._Future.LazyFuture.super(self,l)
  return self
end
tink.core._Future.LazyFuture.super = function(self,l) 
  self.l = l;
end
tink.core._Future.LazyFuture.__name__ = true
tink.core._Future.LazyFuture.__interfaces__ = {tink.core._Future.FutureObject}
tink.core._Future.LazyFuture.prototype = _hx_a(
  'map', function(self,f) 
    do return tink.core._Future.LazyFuture.new(self.l:map(function(future) 
      local ret = future:map(f);
      do return ret:gather() end;
    end)) end
  end,
  'flatMap', function(self,f) 
    do return tink.core._Future.LazyFuture.new(self.l:map(function(future) 
      local ret = future:flatMap(f);
      do return ret:gather() end;
    end)) end
  end,
  'handle', function(self,cb) 
    do return self.l:get():handle(cb) end
  end,
  'gather', function(self) 
    do return tink.core._Future.LazyFuture.new(self.l:map(function(f) 
      do return f:gather() end;
    end)) end
  end,
  'eager', function(self) 
    do return self.l:get():eager() end
  end
  ,'__class__',  tink.core._Future.LazyFuture
)

tink.core._Future.SimpleFuture.new = function(f) 
  local self = _hx_new(tink.core._Future.SimpleFuture.prototype)
  tink.core._Future.SimpleFuture.super(self,f)
  return self
end
tink.core._Future.SimpleFuture.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
tink.core._Future.SimpleFuture.__name__ = true
tink.core._Future.SimpleFuture.__interfaces__ = {tink.core._Future.FutureObject}
tink.core._Future.SimpleFuture.prototype = _hx_a(
  'handle', function(self,callback) 
    do return self:f(callback) end
  end,
  'map', function(self,f) 
    local _gthis = self;
    do return tink.core._Future.SimpleFuture.new(function(cb) 
      do return _gthis:f(function(v) 
        local data = f(v);
        cb(data);
      end) end;
    end) end
  end,
  'flatMap', function(self,f) 
    local f1 = f;
    local _gthis = self;
    do return tink.core._Future.Future_Impl_.flatten(tink.core._Future.SimpleFuture.new(function(cb) 
      do return _gthis:f(function(v) 
        local data = f1(v);
        cb(data);
      end) end;
    end)) end
  end,
  'gather', function(self) 
    do return tink.core.FutureTrigger.gatherFuture(self) end
  end,
  'eager', function(self) 
    local ret = tink.core.FutureTrigger.gatherFuture(self);
    ret:handle(tink.core._Callback.Callback_Impl_.fromNiladic(function() 
    end));
    do return ret end
  end
  ,'__class__',  tink.core._Future.SimpleFuture
)

tink.core._Future.NestedFuture.new = function(outer) 
  local self = _hx_new(tink.core._Future.NestedFuture.prototype)
  tink.core._Future.NestedFuture.super(self,outer)
  return self
end
tink.core._Future.NestedFuture.super = function(self,outer) 
  self.outer = outer;
end
tink.core._Future.NestedFuture.__name__ = true
tink.core._Future.NestedFuture.__interfaces__ = {tink.core._Future.FutureObject}
tink.core._Future.NestedFuture.prototype = _hx_a(
  'map', function(self,f) 
    local ret = self.outer:flatMap(function(inner) 
      local ret1 = inner:map(f);
      do return ret1:gather() end;
    end);
    do return ret:gather() end
  end,
  'flatMap', function(self,f) 
    local ret = self.outer:flatMap(function(inner) 
      local ret1 = inner:flatMap(f);
      do return ret1:gather() end;
    end);
    do return ret:gather() end
  end,
  'gather', function(self) 
    do return tink.core.FutureTrigger.gatherFuture(self) end
  end,
  'eager', function(self) 
    local ret = tink.core.FutureTrigger.gatherFuture(self);
    ret:handle(tink.core._Callback.Callback_Impl_.fromNiladic(function() 
    end));
    do return ret end
  end,
  'handle', function(self,cb) 
    local ret = nil;
    ret = self.outer:handle(function(inner) 
      ret = inner:handle(function(result) 
        cb(result);
      end);
    end);
    do return ret end
  end
  ,'__class__',  tink.core._Future.NestedFuture
)

tink.core.FutureTrigger.new = function() 
  local self = _hx_new(tink.core.FutureTrigger.prototype)
  tink.core.FutureTrigger.super(self)
  return self
end
tink.core.FutureTrigger.super = function(self) 
  local this1 = _hx_tab_array({ }, 0);
  self.list = this1;
end
tink.core.FutureTrigger.__name__ = true
tink.core.FutureTrigger.__interfaces__ = {tink.core._Future.FutureObject}
tink.core.FutureTrigger.gatherFuture = function(f) 
  local op = nil;
  local this1 = tink.core._Future.SimpleFuture.new(function(cb) 
    if (op == nil) then 
      op = tink.core.FutureTrigger.new();
      f:handle(_hx_bind(op,op.trigger));
      f = nil;
    end;
    do return op:handle(cb) end;
  end);
  do return this1 end;
end
tink.core.FutureTrigger.prototype = _hx_a(
  'handle', function(self,callback) 
    local _g = self.list;
    if (_g == nil) then 
      callback(self.result);
      do return nil end;
    else
      local v = _g;
      do return tink.core._Callback.CallbackList_Impl_.add(v,callback) end;
    end;
  end,
  'map', function(self,f) 
    local _g = self.list;
    if (_g == nil) then 
      do return tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(f(self.result))) end;
    else
      local v = _g;
      local ret = tink.core.FutureTrigger.new();
      tink.core._Callback.CallbackList_Impl_.add(self.list,function(v1) 
        local tmp = f(v1);
        ret:trigger(tmp);
      end);
      do return ret end;
    end;
  end,
  'flatMap', function(self,f) 
    local _g = self.list;
    if (_g == nil) then 
      do return f(self.result) end;
    else
      local v = _g;
      local ret = tink.core.FutureTrigger.new();
      tink.core._Callback.CallbackList_Impl_.add(self.list,function(v1) 
        f(v1):handle(_hx_bind(ret,ret.trigger));
      end);
      do return ret end;
    end;
  end,
  'gather', function(self) 
    do return self end
  end,
  'eager', function(self) 
    do return self end
  end,
  'asFuture', function(self) 
    do return self end
  end,
  'trigger', function(self,result) 
    if (self.list == nil) then 
      do return false end;
    else
      local list = self.list;
      self.list = nil;
      self.result = result;
      if (tink.core.FutureTrigger.depth >= 1000) then 
        tink.core._Callback.Callback_Impl_.defer(function() 
          tink.core.FutureTrigger.depth = tink.core.FutureTrigger.depth + 1;
          tink.core._Callback.CallbackList_Impl_.invoke(list,result);
          tink.core._Callback.CallbackList_Impl_.clear(list);
          tink.core.FutureTrigger.depth = tink.core.FutureTrigger.depth - 1;
        end);
      else
        tink.core.FutureTrigger.depth = tink.core.FutureTrigger.depth + 1;
        tink.core._Callback.CallbackList_Impl_.invoke(list,result);
        tink.core._Callback.CallbackList_Impl_.clear(list);
        tink.core.FutureTrigger.depth = tink.core.FutureTrigger.depth - 1;
      end;
      do return true end;
    end;
  end
  ,'__class__',  tink.core.FutureTrigger
)

tink.core._Lazy.Lazy_Impl_.new = {}
tink.core._Lazy.Lazy_Impl_.__name__ = true
tink.core._Lazy.Lazy_Impl_.get = function(this1) 
  do return this1:get() end;
end
tink.core._Lazy.Lazy_Impl_.ofFunc = function(f) 
  do return tink.core._Lazy.LazyFunc.new(f) end;
end
tink.core._Lazy.Lazy_Impl_.map = function(this1,f) 
  do return this1:map(f) end;
end
tink.core._Lazy.Lazy_Impl_.flatMap = function(this1,f) 
  do return this1:flatMap(f) end;
end
tink.core._Lazy.Lazy_Impl_.ofConst = function(c) 
  do return tink.core._Lazy.LazyConst.new(c) end;
end

tink.core._Lazy.LazyObject.new = {}
tink.core._Lazy.LazyObject.__name__ = true
tink.core._Lazy.LazyObject.prototype = _hx_a(
  
  '__class__',  tink.core._Lazy.LazyObject
)

tink.core._Lazy.LazyConst.new = function(value) 
  local self = _hx_new(tink.core._Lazy.LazyConst.prototype)
  tink.core._Lazy.LazyConst.super(self,value)
  return self
end
tink.core._Lazy.LazyConst.super = function(self,value) 
  self.value = value;
end
tink.core._Lazy.LazyConst.__name__ = true
tink.core._Lazy.LazyConst.__interfaces__ = {tink.core._Lazy.LazyObject}
tink.core._Lazy.LazyConst.prototype = _hx_a(
  'get', function(self) 
    do return self.value end
  end,
  'map', function(self,f) 
    do return tink.core._Lazy.LazyConst.new(f(self.value)) end
  end,
  'flatMap', function(self,f) 
    do return f(self.value) end
  end
  ,'__class__',  tink.core._Lazy.LazyConst
)

tink.core._Lazy.LazyFunc.new = function(f) 
  local self = _hx_new(tink.core._Lazy.LazyFunc.prototype)
  tink.core._Lazy.LazyFunc.super(self,f)
  return self
end
tink.core._Lazy.LazyFunc.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
tink.core._Lazy.LazyFunc.__name__ = true
tink.core._Lazy.LazyFunc.__interfaces__ = {tink.core._Lazy.LazyObject}
tink.core._Lazy.LazyFunc.prototype = _hx_a(
  'get', function(self) 
    if (self.f ~= nil) then 
      self.result = self:f();
      self.f = nil;
    end;
    do return self.result end
  end,
  'map', function(self,f) 
    local _gthis = self;
    do return tink.core._Lazy.LazyFunc.new(function() 
      local tmp = _gthis:get();
      do return f(tmp) end;
    end) end
  end,
  'flatMap', function(self,f) 
    local _gthis = self;
    do return tink.core._Lazy.LazyFunc.new(function() 
      local this1 = _gthis:get();
      do return f(this1):get() end;
    end) end
  end
  ,'__class__',  tink.core._Lazy.LazyFunc
)

tink.core.NamedWith.new = function(name,value) 
  local self = _hx_new(tink.core.NamedWith.prototype)
  tink.core.NamedWith.super(self,name,value)
  return self
end
tink.core.NamedWith.super = function(self,name,value) 
  self.name = name;
  self.value = value;
end
tink.core.NamedWith.__name__ = true
tink.core.NamedWith.prototype = _hx_a(
  
  '__class__',  tink.core.NamedWith
)
_hxClasses["tink.core.Noise"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Noise"},1)}
tink.core.Noise = _hxClasses["tink.core.Noise"];
tink.core.Noise.Noise = _hx_tab_array({[0]="Noise",0,__enum__ = tink.core.Noise},2)


tink.core.OptionTools.new = {}
tink.core.OptionTools.__name__ = true
tink.core.OptionTools.force = function(o,pos) 
  if (o[1] == 0) then 
    local v = o[2];
    do return v end;
  else
    _G.error(tink.core.TypedError.new(404,"Some value expected but none found",pos),0);
  end;
end
tink.core.OptionTools["or"] = function(o,l) 
  if (o[1] == 0) then 
    local v = o[2];
    do return v end;
  else
    do return l:get() end;
  end;
end
tink.core.OptionTools.filter = function(o,f) 
  if (o[1] == 0) then 
    local _hx_tmp = f(o[2]);
    if (_hx_tmp == false) then 
      do return haxe.ds.Option.None end;
    else
      do return o end;
    end;
  else
    do return o end;
  end;
end
tink.core.OptionTools.satisfies = function(o,f) 
  if (o[1] == 0) then 
    local v = o[2];
    do return f(v) end;
  else
    do return false end;
  end;
end
tink.core.OptionTools.equals = function(o,v) 
  if (o[1] == 0) then 
    local v1 = o[2];
    do return v1 == v end;
  else
    do return false end;
  end;
end
tink.core.OptionTools.map = function(o,f) 
  if (o[1] == 0) then 
    local v = o[2];
    do return haxe.ds.Option.Some(f(v)) end;
  else
    do return haxe.ds.Option.None end;
  end;
end
tink.core.OptionTools.flatMap = function(o,f) 
  if (o[1] == 0) then 
    local v = o[2];
    do return f(v) end;
  else
    do return haxe.ds.Option.None end;
  end;
end
tink.core.OptionTools.iterator = function(o) 
  do return tink.core.OptionIter.new(o) end;
end
tink.core.OptionTools.toArray = function(o) 
  if (o[1] == 0) then 
    local v = o[2];
    do return _hx_tab_array({[0]=v }, 1) end;
  else
    do return _hx_tab_array({ }, 0) end;
  end;
end

tink.core.OptionIter.new = function(o) 
  local self = _hx_new(tink.core.OptionIter.prototype)
  tink.core.OptionIter.super(self,o)
  return self
end
tink.core.OptionIter.super = function(self,o) 
  self.alive = true;
  if (o[1] == 0) then 
    local v = o[2];
    self.value = v;
  else
    self.alive = false;
  end;
end
tink.core.OptionIter.__name__ = true
tink.core.OptionIter.prototype = _hx_a(
  'hasNext', function(self) 
    do return self.alive end
  end,
  'next', function(self) 
    self.alive = false;
    do return self.value end
  end
  ,'__class__',  tink.core.OptionIter
)
_hxClasses["tink.core.Outcome"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Success","Failure"},2)}
tink.core.Outcome = _hxClasses["tink.core.Outcome"];
tink.core.Outcome.Success = function(data) local _x = _hx_tab_array({[0]="Success",0,data,__enum__=tink.core.Outcome}, 3); return _x; end 
tink.core.Outcome.Failure = function(failure) local _x = _hx_tab_array({[0]="Failure",1,failure,__enum__=tink.core.Outcome}, 3); return _x; end 

tink.core.OutcomeTools.new = {}
tink.core.OutcomeTools.__name__ = true
tink.core.OutcomeTools.sure = function(outcome) 
  local outcome1 = outcome[1];
  if (outcome1) == 0 then 
    local data = outcome[2];
    do return data end;
  elseif (outcome1) == 1 then 
    local failure = outcome[2];
    if (lua.Boot.__instanceof(failure,tink.core.TypedError)) then 
      do return failure:throwSelf() end;
    else
      _G.error(failure,0);
    end; end;
end
tink.core.OutcomeTools.toOption = function(outcome) 
  local outcome1 = outcome[1];
  if (outcome1) == 0 then 
    local data = outcome[2];
    do return haxe.ds.Option.Some(data) end;
  elseif (outcome1) == 1 then 
    do return haxe.ds.Option.None end; end;
end
tink.core.OutcomeTools.toOutcome = function(option,pos) 
  local option1 = option[1];
  if (option1) == 0 then 
    local value = option[2];
    do return tink.core.Outcome.Success(value) end;
  elseif (option1) == 1 then 
    do return tink.core.Outcome.Failure(tink.core.TypedError.new(404,"Some value expected but none found in " .. pos.fileName .. "@line " .. pos.lineNumber,_hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="Outcome.hx",lineNumber=37,className="tink.core.OutcomeTools",methodName="toOutcome"}))) end; end;
end
tink.core.OutcomeTools.orNull = function(outcome) 
  local outcome1 = outcome[1];
  if (outcome1) == 0 then 
    local data = outcome[2];
    do return data end;
  elseif (outcome1) == 1 then 
    do return nil end; end;
end
tink.core.OutcomeTools.orUse = function(outcome,fallback) 
  local outcome1 = outcome[1];
  if (outcome1) == 0 then 
    local data = outcome[2];
    do return data end;
  elseif (outcome1) == 1 then 
    do return fallback:get() end; end;
end
tink.core.OutcomeTools.orTry = function(outcome,fallback) 
  local outcome1 = outcome[1];
  if (outcome1) == 0 then 
    do return outcome end;
  elseif (outcome1) == 1 then 
    do return fallback:get() end; end;
end
tink.core.OutcomeTools.equals = function(outcome,to) 
  local outcome1 = outcome[1];
  if (outcome1) == 0 then 
    local data = outcome[2];
    do return data == to end;
  elseif (outcome1) == 1 then 
    do return false end; end;
end
tink.core.OutcomeTools.map = function(outcome,transform) 
  local outcome1 = outcome[1];
  if (outcome1) == 0 then 
    local a = outcome[2];
    do return tink.core.Outcome.Success(transform(a)) end;
  elseif (outcome1) == 1 then 
    local f = outcome[2];
    do return tink.core.Outcome.Failure(f) end; end;
end
tink.core.OutcomeTools.isSuccess = function(outcome) 
  if (outcome[1] == 0) then 
    do return true end;
  else
    do return false end;
  end;
end
tink.core.OutcomeTools.flatMap = function(o,mapper) 
  do return tink.core._Outcome.OutcomeMapper_Impl_.apply(mapper,o) end;
end
tink.core.OutcomeTools.attempt = function(f,report) 
  local _hx_expected_result = {}
  local _hx_status, _hx_result = pcall(function() 
  
      do return tink.core.Outcome.Success(f()) end;
     return _hx_expected_result end)
   if not _hx_status then 
    local _hx_1 = _hx_result
    local e = _hx_1
    do return tink.core.Outcome.Failure(report(e)) end;
   elseif _hx_result ~= _hx_expected_result then return _hx_result end;
end

tink.core._Outcome.OutcomeMapper_Impl_.new = {}
tink.core._Outcome.OutcomeMapper_Impl_.__name__ = true
tink.core._Outcome.OutcomeMapper_Impl_._new = function(f) 
  local this1 = _hx_o({__fields__={f=true},f=f});
  do return this1 end;
end
tink.core._Outcome.OutcomeMapper_Impl_.apply = function(this1,o) 
  do return this1:f(o) end;
end
tink.core._Outcome.OutcomeMapper_Impl_.withSameError = function(f) 
  do return tink.core._Outcome.OutcomeMapper_Impl_._new(function(o) 
    local o1 = o[1];
    if (o1) == 0 then 
      local d = o[2];
      do return f(d) end;
    elseif (o1) == 1 then 
      local f1 = o[2];
      do return tink.core.Outcome.Failure(f1) end; end;
  end) end;
end
tink.core._Outcome.OutcomeMapper_Impl_.withEitherError = function(f) 
  do return tink.core._Outcome.OutcomeMapper_Impl_._new(function(o) 
    local o1 = o[1];
    if (o1) == 0 then 
      local d = o[2];
      local _g = f(d);
      local _g1 = _g[1];
      if (_g1) == 0 then 
        local d1 = _g[2];
        do return tink.core.Outcome.Success(d1) end;
      elseif (_g1) == 1 then 
        local f1 = _g[2];
        do return tink.core.Outcome.Failure(haxe.ds.Either.Right(f1)) end; end;
    elseif (o1) == 1 then 
      local f2 = o[2];
      do return tink.core.Outcome.Failure(haxe.ds.Either.Left(f2)) end; end;
  end) end;
end

tink.core._Pair.Pair_Impl_.new = {}
tink.core._Pair.Pair_Impl_.__name__ = true
tink.core._Pair.Pair_Impl_._new = function(a,b) 
  local this1 = tink.core.MPair.new(a,b);
  do return this1 end;
end
tink.core._Pair.Pair_Impl_.get_a = function(this1) 
  do return this1.a end;
end
tink.core._Pair.Pair_Impl_.get_b = function(this1) 
  do return this1.b end;
end
tink.core._Pair.Pair_Impl_.toBool = function(this1) 
  do return this1 ~= nil end;
end
tink.core._Pair.Pair_Impl_.isNil = function(this1) 
  do return this1 == nil end;
end
tink.core._Pair.Pair_Impl_["nil"] = function() 
  do return nil end;
end

tink.core.MPair.new = function(a,b) 
  local self = _hx_new(tink.core.MPair.prototype)
  tink.core.MPair.super(self,a,b)
  return self
end
tink.core.MPair.super = function(self,a,b) 
  self.a = a;
  self.b = b;
end
tink.core.MPair.__name__ = true
tink.core.MPair.prototype = _hx_a(
  
  '__class__',  tink.core.MPair
)

tink.core._Promise.Promise_Impl_.new = {}
tink.core._Promise.Promise_Impl_.__name__ = true
tink.core._Promise.Promise_Impl_.map = function(this1,f) 
  local ret = this1:map(f);
  do return ret:gather() end;
end
tink.core._Promise.Promise_Impl_.flatMap = function(this1,f) 
  local ret = this1:flatMap(f);
  do return ret:gather() end;
end
tink.core._Promise.Promise_Impl_.recover = function(this1,f) 
  local ret = this1:flatMap(function(o) 
    local o1 = o[1];
    if (o1) == 0 then 
      local d = o[2];
      do return tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(d)) end;
    elseif (o1) == 1 then 
      local e = o[2];
      do return f(e) end; end;
  end);
  do return ret:gather() end;
end
tink.core._Promise.Promise_Impl_.handle = function(this1,cb) 
  do return this1:handle(cb) end;
end
tink.core._Promise.Promise_Impl_.noise = function(this1) 
  do return tink.core._Promise.Promise_Impl_.next(this1,function(v) 
    do return tink.core._Promise.Promise_Impl_.ofOutcome(tink.core.Outcome.Success(tink.core.Noise.Noise)) end;
  end) end;
end
tink.core._Promise.Promise_Impl_.next = function(this1,f) 
  do return tink.core._Future.Future_Impl_._tryFailingFlatMap(this1,function(result) 
    do return f(result) end;
  end) end;
end
tink.core._Promise.Promise_Impl_.ofSpecific = function(s) 
  do return s end;
end
tink.core._Promise.Promise_Impl_.ofFuture = function(f) 
  local ret = f:map(tink.core.Outcome.Success);
  do return ret:gather() end;
end
tink.core._Promise.Promise_Impl_.ofOutcome = function(o) 
  do return tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(o)) end;
end
tink.core._Promise.Promise_Impl_.ofError = function(e) 
  do return tink.core._Promise.Promise_Impl_.ofOutcome(tink.core.Outcome.Failure(e)) end;
end
tink.core._Promise.Promise_Impl_.ofData = function(d) 
  do return tink.core._Promise.Promise_Impl_.ofOutcome(tink.core.Outcome.Success(d)) end;
end
tink.core._Promise.Promise_Impl_.lift = function(p) 
  do return p end;
end

tink.core._Promise.Next_Impl_.new = {}
tink.core._Promise.Next_Impl_.__name__ = true
tink.core._Promise.Next_Impl_.ofSafe = function(f) 
  do return function(x) 
    do return tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(f(x))) end;
  end end;
end
tink.core._Promise.Next_Impl_.ofSync = function(f) 
  do return function(x) 
    local ret = f(x):map(tink.core.Outcome.Success);
    do return ret:gather() end;
  end end;
end
tink.core._Promise.Next_Impl_.ofSafeSync = function(f) 
  do return function(x) 
    do return tink.core._Promise.Promise_Impl_.ofOutcome(tink.core.Outcome.Success(f(x))) end;
  end end;
end
tink.core._Promise.Next_Impl_._chain = function(a,b) 
  do return function(v) 
    do return tink.core._Promise.Promise_Impl_.next(a(v),b) end;
  end end;
end

tink.core._Promise.Recover_Impl_.new = {}
tink.core._Promise.Recover_Impl_.__name__ = true
tink.core._Promise.Recover_Impl_.ofSync = function(f) 
  do return function(e) 
    do return tink.core._Future.SyncFuture.new(tink.core._Lazy.LazyConst.new(f(e))) end;
  end end;
end

tink.core._Ref.Ref_Impl_.new = {}
tink.core._Ref.Ref_Impl_.__name__ = true
tink.core._Ref.Ref_Impl_._new = function() 
  local this1;
  local this2 = ({length = 1});
  this1 = this2;
  do return this1 end;
end
tink.core._Ref.Ref_Impl_.get_value = function(this1) 
  do return this1[0] end;
end
tink.core._Ref.Ref_Impl_.set_value = function(this1,param) 
  do return (function() 
  this1[0] = param; return this1[0] end)() end;
end
tink.core._Ref.Ref_Impl_.toString = function(this1) 
  do return "@[" .. Std.string(this1[0]) .. "]" end;
end
tink.core._Ref.Ref_Impl_.to = function(v) 
  local this1;
  local this2 = ({length = 1});
  this1 = this2;
  local ret = this1;
  ret[0] = v;
  do return ret end;
end

tink.core._Signal.Signal_Impl_.new = {}
tink.core._Signal.Signal_Impl_.__name__ = true
tink.core._Signal.Signal_Impl_._new = function(f) 
  local this1 = tink.core._Signal.SimpleSignal.new(f);
  do return this1 end;
end
tink.core._Signal.Signal_Impl_.handle = function(this1,handler) 
  do return this1:handle(handler) end;
end
tink.core._Signal.Signal_Impl_.map = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = tink.core._Signal.SimpleSignal.new(function(cb) 
    do return this1:handle(function(result) 
      local data = f(result);
      cb(data);
    end) end;
  end);
  local ret = this2;
  if (gather) then 
    do return tink.core._Signal.Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
tink.core._Signal.Signal_Impl_.flatMap = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = tink.core._Signal.SimpleSignal.new(function(cb) 
    do return this1:handle(function(result) 
      f(result):handle(cb);
    end) end;
  end);
  local ret = this2;
  if (gather) then 
    do return tink.core._Signal.Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
tink.core._Signal.Signal_Impl_.filter = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = tink.core._Signal.SimpleSignal.new(function(cb) 
    do return this1:handle(function(result) 
      if (f(result)) then 
        cb(result);
      end;
    end) end;
  end);
  local ret = this2;
  if (gather) then 
    do return tink.core._Signal.Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
tink.core._Signal.Signal_Impl_.join = function(this1,other,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = tink.core._Signal.SimpleSignal.new(function(cb) 
    do return tink.core._Callback.LinkPair.new(this1:handle(cb),other:handle(cb)) end;
  end);
  local ret = this2;
  if (gather) then 
    do return tink.core._Signal.Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
tink.core._Signal.Signal_Impl_.next = function(this1) 
  local ret = tink.core.FutureTrigger.new();
  local link = nil;
  local immediate = false;
  link = this1:handle(function(v) 
    ret:trigger(v);
    if (link == nil) then 
      immediate = true;
    else
      if (link ~= nil) then 
        link:dissolve();
      end;
    end;
  end);
  if (immediate) then 
    if (link ~= nil) then 
      link:dissolve();
    end;
  end;
  do return ret end;
end
tink.core._Signal.Signal_Impl_.noise = function(this1) 
  do return tink.core._Signal.Signal_Impl_.map(this1,function(_) 
    do return tink.core.Noise.Noise end;
  end) end;
end
tink.core._Signal.Signal_Impl_.gather = function(this1) 
  local ret = tink.core._Signal.Signal_Impl_.trigger();
  this1:handle(function(x) 
    tink.core._Callback.CallbackList_Impl_.invoke(ret.handlers,x);
  end);
  do return ret end;
end
tink.core._Signal.Signal_Impl_.trigger = function() 
  do return tink.core.SignalTrigger.new() end;
end
tink.core._Signal.Signal_Impl_.ofClassical = function(add,remove,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this1 = tink.core._Signal.SimpleSignal.new(function(cb) 
    local f = function(a) 
      cb(a);
    end;
    add(f);
    local this2;
    local f1 = remove;
    local a1 = f;
    this2 = tink.core._Callback.SimpleLink.new(function() 
      f1(a1);
    end);
    do return this2 end;
  end);
  local ret = this1;
  if (gather) then 
    do return tink.core._Signal.Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end

tink.core.SignalObject.new = {}
tink.core.SignalObject.__name__ = true
tink.core.SignalObject.prototype = _hx_a(
  
  '__class__',  tink.core.SignalObject
)

tink.core._Signal.SimpleSignal.new = function(f) 
  local self = _hx_new(tink.core._Signal.SimpleSignal.prototype)
  tink.core._Signal.SimpleSignal.super(self,f)
  return self
end
tink.core._Signal.SimpleSignal.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
tink.core._Signal.SimpleSignal.__name__ = true
tink.core._Signal.SimpleSignal.__interfaces__ = {tink.core.SignalObject}
tink.core._Signal.SimpleSignal.prototype = _hx_a(
  'handle', function(self,cb) 
    do return self:f(cb) end
  end
  ,'__class__',  tink.core._Signal.SimpleSignal
)

tink.core.SignalTrigger.new = function() 
  local self = _hx_new(tink.core.SignalTrigger.prototype)
  tink.core.SignalTrigger.super(self)
  return self
end
tink.core.SignalTrigger.super = function(self) 
  local this1 = _hx_tab_array({ }, 0);
  self.handlers = this1;
end
tink.core.SignalTrigger.__name__ = true
tink.core.SignalTrigger.__interfaces__ = {tink.core.SignalObject}
tink.core.SignalTrigger.prototype = _hx_a(
  'trigger', function(self,event) 
    tink.core._Callback.CallbackList_Impl_.invoke(self.handlers,event);
  end,
  'getLength', function(self) 
    do return self.handlers.length end
  end,
  'handle', function(self,cb) 
    do return tink.core._Callback.CallbackList_Impl_.add(self.handlers,cb) end
  end,
  'clear', function(self) 
    tink.core._Callback.CallbackList_Impl_.clear(self.handlers);
  end,
  'asSignal', function(self) 
    do return self end
  end
  ,'__class__',  tink.core.SignalTrigger
)

tink.url._Auth.Auth_Impl_.new = {}
tink.url._Auth.Auth_Impl_.__name__ = true
tink.url._Auth.Auth_Impl_._new = function(user,password) 
  local this1 = "" .. user .. ":" .. password;
  do return this1 end;
end
tink.url._Auth.Auth_Impl_.get_user = function(this1) 
  if (this1 == nil) then 
    do return nil end;
  else
    do return this1:split(":")[0] end;
  end;
end
tink.url._Auth.Auth_Impl_.get_password = function(this1) 
  if (this1 == nil) then 
    do return nil end;
  else
    do return this1:split(":")[1] end;
  end;
end

tink.url._Host.Host_Impl_.new = {}
tink.url._Host.Host_Impl_.__name__ = true
tink.url._Host.Host_Impl_._new = function(name,port) 
  local this1;
  if (port == nil) then 
    this1 = name;
  else
    if ((port > 65535) or (port <= 0)) then 
      _G.error("Invalid port",0);
    else
      this1 = "" .. name .. ":" .. port;
    end;
  end;
  do return this1 end;
end
tink.url._Host.Host_Impl_.get_name = function(this1) 
  if (this1 == nil) then 
    do return nil end;
  else
    local _g = this1:split("]");
    local _g1 = _g.length;
    if (_g1) == 1 then 
      local v = _g[0];
      do return v:split(":")[0] end;
    elseif (_g1) == 2 then 
      local v1 = _g[0];
      do return v1 .. "]" end;else
    _G.error("assert",0); end;
  end;
end
tink.url._Host.Host_Impl_.get_port = function(this1) 
  if (this1 == nil) then 
    do return nil end;
  else
    local _g = this1:split("]");
    local _g1 = _g.length;
    if (_g1) == 1 then 
      local v = _g[0];
      local _g2 = v:split(":")[1];
      if (_g2 == nil) then 
        do return nil end;
      else
        local p = _g2;
        do return Std.parseInt(p) end;
      end;
    elseif (_g1) == 2 then 
      local v1 = _g[1];
      local _g3 = v1:split(":")[1];
      if (_g3 == nil) then 
        do return nil end;
      else
        local p1 = _g3;
        do return Std.parseInt(p1) end;
      end;else
    _G.error("assert",0); end;
  end;
end

tink.url._Path.Path_Impl_.new = {}
tink.url._Path.Path_Impl_.__name__ = true
tink.url._Path.Path_Impl_.parts = function(this1) 
  local _g = _hx_tab_array({ }, 0);
  local _g1 = 0;
  local _g2 = this1:split("/");
  while (_g1 < _g2.length) do 
    local p = _g2[_g1];
    _g1 = _g1 + 1;
    if (p ~= "") then 
      local this2 = p;
      _g:push(this2);
    end;
    end;
  do return _g end;
end
tink.url._Path.Path_Impl_.get_absolute = function(this1) 
  do return this1:charAt(0) == "/" end;
end
tink.url._Path.Path_Impl_.get_isDir = function(this1) 
  do return this1:charAt(this1.length - 1) == "/" end;
end
tink.url._Path.Path_Impl_._new = function(s) 
  local this1 = s;
  do return this1 end;
end
tink.url._Path.Path_Impl_.join = function(this1,that) 
  if (that == "") then 
    do return this1 end;
  else
    if (that:charAt(0) == "/") then 
      do return that end;
    else
      if (this1:charAt(this1.length - 1) == "/") then 
        do return tink.url._Path.Path_Impl_.ofString(this1 .. that) end;
      else
        local _g = this1:lastIndexOf("/");
        if (_g == -1) then 
          do return that end;
        else
          local v = _g;
          do return tink.url._Path.Path_Impl_.ofString(this1:substr(0,v + 1) .. that) end;
        end;
      end;
    end;
  end;
end
tink.url._Path.Path_Impl_.ofString = function(s) 
  local this1 = tink.url._Path.Path_Impl_.normalize(s);
  do return this1 end;
end
tink.url._Path.Path_Impl_.normalize = function(s) 
  s = StringTools.trim(StringTools.replace(s,"\\","/"));
  if (s == ".") then 
    do return "./" end;
  end;
  local isDir = (StringTools.endsWith(s,"/..") or StringTools.endsWith(s,"/")) or StringTools.endsWith(s,"/.");
  local parts = _hx_tab_array({ }, 0);
  local isAbsolute = StringTools.startsWith(s,"/");
  local up = 0;
  local _g = 0;
  local _g1 = s:split("/");
  while (_g < _g1.length) do 
    local part = _g1[_g];
    _g = _g + 1;
    local _g2 = StringTools.trim(part);
    local _g21 = _g2;
    if (_g21) == "" then 
    elseif (_g21) == "." then 
    elseif (_g21) == ".." then 
      if (parts:pop() == nil) then 
        up = up + 1;
      end;else
    local v = _g2;
    parts:push(v); end;
    end;
  if (isAbsolute) then 
    parts:unshift("");
  else
    local _g11 = 0;
    local _g3 = up;
    while (_g11 < _g3) do 
      _g11 = _g11 + 1;
      local i = _g11 - 1;
      parts:unshift("..");
      end;
  end;
  if (isDir) then 
    parts:push("");
  end;
  do return parts:join("/") end;
end

tink.url._Portion.Portion_Impl_.new = {}
tink.url._Portion.Portion_Impl_.__name__ = true
tink.url._Portion.Portion_Impl_.get_raw = function(this1) 
  do return this1 end;
end
tink.url._Portion.Portion_Impl_._new = function(v) 
  local this1 = v;
  do return this1 end;
end
tink.url._Portion.Portion_Impl_.stringly = function(this1) 
  do return tink.url._Portion.Portion_Impl_.toString(this1) end;
end
tink.url._Portion.Portion_Impl_.toString = function(this1) 
  if (this1 == nil) then 
    do return nil end;
  else
    do return StringTools.urlDecode(this1) end;
  end;
end
tink.url._Portion.Portion_Impl_.ofString = function(s) 
  local this1 = (function() 
    local _hx_1
    if (s == nil) then 
    _hx_1 = ""; else 
    _hx_1 = StringTools.urlEncode(s); end
    return _hx_1
  end )();
  do return this1 end;
end

tink.url._Query.Query_Impl_.new = {}
tink.url._Query.Query_Impl_.__name__ = true
tink.url._Query.Query_Impl_.parse = function(this1) 
  do return tink.url._Query.QueryStringParser.new(this1,"&","=",0) end;
end
tink.url._Query.Query_Impl_.iterator = function(this1) 
  do return tink.url._Query.QueryStringParser.new(this1,"&","=",0) end;
end
tink.url._Query.Query_Impl_.toMap = function(this1) 
  local _g = haxe.ds.StringMap.new();
  local p = tink.url._Query.QueryStringParser.new(this1,"&","=",0);
  while (p:hasNext()) do 
    local p1 = p:next();
    local key = p1.name:toString();
    local value = p1.value;
    _g.v[key] = value;
    _g.k[key] = true;
    end;
  do return _g end;
end
tink.url._Query.Query_Impl_.ofObj = function(v) 
  local this1 = _hx_tab_array({ }, 0);
  local ret = this1;
  local v1 = v;
  local _g = 0;
  local _g1 = Reflect.fields(v1);
  while (_g < _g1.length) do 
    local k = _g1[_g];
    _g = _g + 1;
    ret:push(tink.url._Portion.Portion_Impl_.ofString(k) .. "=" .. tink.url._Portion.Portion_Impl_.ofString(Reflect.field(v1,k)));
    end;
  do return ret:join("&") end;
end
tink.url._Query.Query_Impl_.build = function() 
  local this1 = _hx_tab_array({ }, 0);
  do return this1 end;
end
tink.url._Query.Query_Impl_.parseString = function(s,sep,set,pos) 
  if (pos == nil) then 
    pos = 0;
  end;
  if (set == nil) then 
    set = "=";
  end;
  if (sep == nil) then 
    sep = "&";
  end;
  do return tink.url._Query.QueryStringParser.new(s,sep,set,pos) end;
end

tink.url._Query.QueryStringBuilder_Impl_.new = {}
tink.url._Query.QueryStringBuilder_Impl_.__name__ = true
tink.url._Query.QueryStringBuilder_Impl_._new = function() 
  local this1 = _hx_tab_array({ }, 0);
  do return this1 end;
end
tink.url._Query.QueryStringBuilder_Impl_.add = function(this1,name,value) 
  this1:push(name .. "=" .. value);
  do return this1 end;
end
tink.url._Query.QueryStringBuilder_Impl_.toString = function(this1) 
  do return this1:join("&") end;
end
tink.url._Query.QueryStringBuilder_Impl_.copy = function(this1) 
  local _g = _hx_tab_array({ }, 0);
  local _g1 = 0;
  local _g2 = this1;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
    end;
  do return _g end;
end

tink.url._Query.QueryStringParser.new = function(s,sep,set,pos) 
  local self = _hx_new(tink.url._Query.QueryStringParser.prototype)
  tink.url._Query.QueryStringParser.super(self,s,sep,set,pos)
  return self
end
tink.url._Query.QueryStringParser.super = function(self,s,sep,set,pos) 
  self.s = (function() 
    local _hx_1
    if (s == nil) then 
    _hx_1 = ""; else 
    _hx_1 = s; end
    return _hx_1
  end )();
  self.sep = sep;
  self.set = set;
  self.pos = pos;
end
tink.url._Query.QueryStringParser.__name__ = true
tink.url._Query.QueryStringParser.trimmedSub = function(s,start,_end) 
  while (_G.string.byte(s,start + 1) < 33) do 
    start = start + 1;
    end;
  if (_end < (s.length - 1)) then 
    while (_G.string.byte(s,(_end - 1) + 1) < 33) do 
      _end = _end - 1;
      end;
  end;
  local this1 = s:substring(start,_end);
  do return this1 end;
end
tink.url._Query.QueryStringParser.prototype = _hx_a(
  'hasNext', function(self) 
    do return self.pos < self.s.length end
  end,
  'next', function(self) 
    local next = self.s:indexOf(self.sep,self.pos);
    if (next == -1) then 
      next = self.s.length;
    end;
    local split = self.s:indexOf(self.set,self.pos);
    local start = self.pos;
    self.pos = next + self.sep.length;
    if ((split == -1) or (split > next)) then 
      do return tink.core.NamedWith.new(tink.url._Portion.Portion_Impl_.stringly(tink.url._Query.QueryStringParser.trimmedSub(self.s,start,next)),tink.url._Portion.Portion_Impl_.ofString("")) end;
    else
      do return tink.core.NamedWith.new(tink.url._Portion.Portion_Impl_.stringly(tink.url._Query.QueryStringParser.trimmedSub(self.s,start,split)),tink.url._Query.QueryStringParser.trimmedSub(self.s,split + self.set.length,next)) end;
    end;
  end
  ,'__class__',  tink.url._Query.QueryStringParser
)

zephyr.HtmlBuilder.new = {}
zephyr.HtmlBuilder.__name__ = true
zephyr.HtmlBuilder.html = function(options,tags) 
  do return zephyr.tag.Tag.new("html",options,tags) end;
end
zephyr.HtmlBuilder.head = function(options,tags) 
  do return zephyr.tag.Tag.new("head",options,tags) end;
end
zephyr.HtmlBuilder.link = function(options) 
  do return zephyr.tag.link.LinkTag.new(options) end;
end
zephyr.HtmlBuilder.script = function(options) 
  do return zephyr.tag.script.ScriptTag.new(options) end;
end
zephyr.HtmlBuilder.body = function(options,tags) 
  do return zephyr.tag.Tag.new("body",options,tags) end;
end
zephyr.HtmlBuilder.div = function(options,tags) 
  do return zephyr.tag.TextTag.new("div",options,tags) end;
end
zephyr.HtmlBuilder.span = function(options,tags) 
  do return zephyr.tag.TextTag.new("span",options,tags) end;
end
zephyr.HtmlBuilder.ul = function(options,tags) 
  do return zephyr.tag.TextTag.new("ul",options,tags) end;
end
zephyr.HtmlBuilder.li = function(options,tags) 
  do return zephyr.tag.TextTag.new("li",options,tags) end;
end
zephyr.HtmlBuilder.p = function(options,tags) 
  do return zephyr.tag.TextTag.new("p",options,tags) end;
end
zephyr.HtmlBuilder.a = function(options,tags) 
  do return zephyr.tag.ATag.new(options,tags) end;
end
zephyr.HtmlBuilder.form = function(options,tags) 
  do return zephyr.tag.FormTag.new(options,tags) end;
end
zephyr.HtmlBuilder.input = function(options,tags) 
  do return zephyr.tag.InputTag.new(options,tags) end;
end
zephyr.HtmlBuilder.button = function(options,tags) 
  do return zephyr.tag.button.ButtonTag.new(options,tags) end;
end
zephyr.HtmlBuilder.label = function(options,tags) 
  do return zephyr.tag.TextTag.new("label",options,tags) end;
end
zephyr.HtmlBuilder.h1 = function(options,tags) 
  do return zephyr.tag.TextTag.new("h1",options,tags) end;
end

zephyr.tag.Tag.new = function(name,options,tags) 
  local self = _hx_new(zephyr.tag.Tag.prototype)
  zephyr.tag.Tag.super(self,name,options,tags)
  return self
end
zephyr.tag.Tag.super = function(self,name,options,tags) 
  self.attributes = haxe.ds.StringMap.new();
  self.Name = name;
  self.childs = (function() 
    local _hx_1
    if (tags ~= nil) then 
    _hx_1 = tags; else 
    _hx_1 = Array.new(); end
    return _hx_1
  end )();
  if (options ~= nil) then 
    if (options.css ~= nil) then 
      local v = options.css;
      local _this = self.attributes;
      _this.v["class"] = v;
      _this.k["class"] = true;
    end;
    if (options.id ~= nil) then 
      local v1 = options.id;
      local _this1 = self.attributes;
      _this1.v["id"] = v1;
      _this1.k["id"] = true;
    end;
    if (options.style ~= nil) then 
      local v2 = options.style;
      local _this2 = self.attributes;
      _this2.v["style"] = v2;
      _this2.k["style"] = true;
    end;
  end;
end
zephyr.tag.Tag.__name__ = true
zephyr.tag.Tag.prototype = _hx_a(
  'get_Css', function(self) 
    local this1 = self.attributes;
    if ((this1.k["class"] or false)) then 
      local this2 = self.attributes;
      do return this2.v["class"] end;
    end;
    do return "" end
  end,
  'addTags', function(self,tags) 
    self.childs = self.childs:concat(tags);
  end,
  'renderName', function(self) 
    local s = StringBuf.new();
    local str = Std.string("<" .. self.Name);
    _G.table.insert(s.b,str);
    local s1 = s;
    s1.length = s1.length + str.length;
    local i = self.attributes:keys();
    while (i:hasNext()) do 
      local i1 = i:next();
      local str1 = " ";
      _G.table.insert(s.b,str1);
      local s2 = s;
      s2.length = s2.length + str1.length;
      local this1 = self.attributes;
      local str2 = Std.string("" .. i1 .. "=\"" .. this1.v[i1] .. "\"");
      _G.table.insert(s.b,str2);
      local s3 = s;
      s3.length = s3.length + str2.length;
      end;
    local str3 = ">";
    _G.table.insert(s.b,str3);
    local s4 = s;
    s4.length = s4.length + str3.length;
    do return s end
  end,
  'renderChilds', function(self,s) 
    local _g = 0;
    local _g1 = self.childs;
    while (_g < _g1.length) do 
      local tag = _g1[_g];
      _g = _g + 1;
      local str = Std.string(tag:toString());
      _G.table.insert(s.b,str);
      local s1 = s;
      s1.length = s1.length + str.length;
      end;
  end,
  'closeTag', function(self,s) 
    local str = Std.string("</" .. self.Name .. ">");
    _G.table.insert(s.b,str);
    local s1 = s;
    s1.length = s1.length + str.length;
  end,
  'toString', function(self) 
    local s = self:renderName();
    self:renderChilds(s);
    self:closeTag(s);
    do return _G.table.concat(s.b) end
  end
  ,'__class__',  zephyr.tag.Tag
)
zephyr.tag.Tag.__super__ = chocolate.response.AbstractResponse
setmetatable(zephyr.tag.Tag.prototype,{__index=chocolate.response.AbstractResponse.prototype})

zephyr.tag.TextTag.new = function(name,options,tags) 
  local self = _hx_new(zephyr.tag.TextTag.prototype)
  zephyr.tag.TextTag.super(self,name,options,tags)
  return self
end
zephyr.tag.TextTag.super = function(self,name,options,tags) 
  zephyr.tag.Tag.super(self,name,options,tags);
  self.text = "";
  if (options ~= nil) then 
    self.text = (function() 
      local _hx_1
      if (options.text ~= nil) then 
      _hx_1 = options.text; else 
      _hx_1 = ""; end
      return _hx_1
    end )();
  end;
end
zephyr.tag.TextTag.__name__ = true
zephyr.tag.TextTag.prototype = _hx_a(
  'toString', function(self) 
    local s = self:renderName();
    if (self.text ~= "") then 
      local str = Std.string(self.text);
      _G.table.insert(s.b,str);
      local s1 = s;
      s1.length = s1.length + str.length;
    end;
    self:renderChilds(s);
    self:closeTag(s);
    do return _G.table.concat(s.b) end
  end
  ,'__class__',  zephyr.tag.TextTag
)
zephyr.tag.TextTag.__super__ = zephyr.tag.Tag
setmetatable(zephyr.tag.TextTag.prototype,{__index=zephyr.tag.Tag.prototype})

zephyr.tag.ATag.new = function(options,tags) 
  local self = _hx_new(zephyr.tag.ATag.prototype)
  zephyr.tag.ATag.super(self,options,tags)
  return self
end
zephyr.tag.ATag.super = function(self,options,tags) 
  zephyr.tag.TextTag.super(self,"a",options,tags);
  local v = options.href;
  local _this = self.attributes;
  _this.v["href"] = v;
  _this.k["href"] = true;
end
zephyr.tag.ATag.__name__ = true
zephyr.tag.ATag.prototype = _hx_a(
  
  '__class__',  zephyr.tag.ATag
)
zephyr.tag.ATag.__super__ = zephyr.tag.TextTag
setmetatable(zephyr.tag.ATag.prototype,{__index=zephyr.tag.TextTag.prototype})

zephyr.tag._FormMethodType.FormMethodType_Impl_.new = {}
zephyr.tag._FormMethodType.FormMethodType_Impl_.__name__ = true
zephyr.tag._FormMethodType.FormMethodType_Impl_._new = function(s) 
  local this1 = s;
  do return this1 end;
end
zephyr.tag._FormMethodType.FormMethodType_Impl_.fromString = function(s) 
  do return zephyr.tag._FormMethodType.FormMethodType_Impl_._new(s) end;
end

zephyr.tag.FormTag.new = function(options,tags) 
  local self = _hx_new(zephyr.tag.FormTag.prototype)
  zephyr.tag.FormTag.super(self,options,tags)
  return self
end
zephyr.tag.FormTag.super = function(self,options,tags) 
  zephyr.tag.Tag.super(self,"form",nil,tags);
  if (options.action ~= nil) then 
    local v = options.action;
    local _this = self.attributes;
    _this.v["action"] = v;
    _this.k["action"] = true;
  end;
  if (options.method ~= nil) then 
    local v1 = options.method;
    local _this1 = self.attributes;
    _this1.v["method"] = v1;
    _this1.k["method"] = true;
  end;
end
zephyr.tag.FormTag.__name__ = true
zephyr.tag.FormTag.prototype = _hx_a(
  
  '__class__',  zephyr.tag.FormTag
)
zephyr.tag.FormTag.__super__ = zephyr.tag.Tag
setmetatable(zephyr.tag.FormTag.prototype,{__index=zephyr.tag.Tag.prototype})

zephyr.tag.InputTag.new = function(options,tags) 
  local self = _hx_new(zephyr.tag.InputTag.prototype)
  zephyr.tag.InputTag.super(self,options,tags)
  return self
end
zephyr.tag.InputTag.super = function(self,options,tags) 
  zephyr.tag.Tag.super(self,"input",nil,tags);
  local v = options.type;
  local _this = self.attributes;
  _this.v["type"] = v;
  _this.k["type"] = true;
  if (options.autocomplete ~= nil) then 
    local v1 = (function() 
      local _hx_1
      if (options.autocomplete) then 
      _hx_1 = "on"; else 
      _hx_1 = "off"; end
      return _hx_1
    end )();
    local _this1 = self.attributes;
    _this1.v["autocomplete"] = v1;
    _this1.k["autocomplete"] = true;
  end;
  if (options.required) then 
    local _this2 = self.attributes;
    _this2.v["required"] = "";
    _this2.k["required"] = true;
  end;
end
zephyr.tag.InputTag.__name__ = true
zephyr.tag.InputTag.prototype = _hx_a(
  
  '__class__',  zephyr.tag.InputTag
)
zephyr.tag.InputTag.__super__ = zephyr.tag.Tag
setmetatable(zephyr.tag.InputTag.prototype,{__index=zephyr.tag.Tag.prototype})

zephyr.tag._InputType.InputType_Impl_.new = {}
zephyr.tag._InputType.InputType_Impl_.__name__ = true
zephyr.tag._InputType.InputType_Impl_._new = function(s) 
  local this1 = s;
  do return this1 end;
end
zephyr.tag._InputType.InputType_Impl_.fromString = function(s) 
  do return zephyr.tag._InputType.InputType_Impl_._new(s) end;
end

zephyr.tag.button.ButtonTag.new = function(options,tags) 
  local self = _hx_new(zephyr.tag.button.ButtonTag.prototype)
  zephyr.tag.button.ButtonTag.super(self,options,tags)
  return self
end
zephyr.tag.button.ButtonTag.super = function(self,options,tags) 
  zephyr.tag.TextTag.super(self,"button",options,tags);
  if (options.type ~= nil) then 
    local v = options.type;
    local _this = self.attributes;
    _this.v["type"] = v;
    _this.k["type"] = true;
  end;
end
zephyr.tag.button.ButtonTag.__name__ = true
zephyr.tag.button.ButtonTag.prototype = _hx_a(
  
  '__class__',  zephyr.tag.button.ButtonTag
)
zephyr.tag.button.ButtonTag.__super__ = zephyr.tag.TextTag
setmetatable(zephyr.tag.button.ButtonTag.prototype,{__index=zephyr.tag.TextTag.prototype})

zephyr.tag.link.LinkTag.new = function(options) 
  local self = _hx_new(zephyr.tag.link.LinkTag.prototype)
  zephyr.tag.link.LinkTag.super(self,options)
  return self
end
zephyr.tag.link.LinkTag.super = function(self,options) 
  zephyr.tag.Tag.super(self,"link");
  local v = options.rel;
  local _this = self.attributes;
  _this.v["rel"] = v;
  _this.k["rel"] = true;
  local v1 = options.href;
  local _this1 = self.attributes;
  _this1.v["href"] = v1;
  _this1.k["href"] = true;
end
zephyr.tag.link.LinkTag.__name__ = true
zephyr.tag.link.LinkTag.prototype = _hx_a(
  
  '__class__',  zephyr.tag.link.LinkTag
)
zephyr.tag.link.LinkTag.__super__ = zephyr.tag.Tag
setmetatable(zephyr.tag.link.LinkTag.prototype,{__index=zephyr.tag.Tag.prototype})

zephyr.tag.script.ScriptTag.new = function(options) 
  local self = _hx_new(zephyr.tag.script.ScriptTag.prototype)
  zephyr.tag.script.ScriptTag.super(self,options)
  return self
end
zephyr.tag.script.ScriptTag.super = function(self,options) 
  zephyr.tag.Tag.super(self,"script");
  if (options.type ~= nil) then 
    local v = options.type;
    local _this = self.attributes;
    _this.v["type"] = v;
    _this.k["type"] = true;
  end;
  if (options.type ~= nil) then 
    local v1 = options.src;
    local _this1 = self.attributes;
    _this1.v["src"] = v1;
    _this1.k["src"] = true;
  end;
end
zephyr.tag.script.ScriptTag.__name__ = true
zephyr.tag.script.ScriptTag.prototype = _hx_a(
  
  '__class__',  zephyr.tag.script.ScriptTag
)
zephyr.tag.script.ScriptTag.__super__ = zephyr.tag.Tag
setmetatable(zephyr.tag.script.ScriptTag.prototype,{__index=zephyr.tag.Tag.prototype})
_hx_bit_clamp = function(v) 
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end
pcall(require, 'bit')
if bit then
  _hx_bit = bit
elseif bit32 then
  local _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

EReg.FLAGS = lua.lib.lrexlib.Rex.flags()
haxe.EntryPoint.sleepLock = haxe._EntryPoint.Lock.new()
haxe.EntryPoint.mutex = haxe._EntryPoint.Mutex.new()
haxe.EntryPoint.pending = Array.new()
haxe.EntryPoint.threadCount = 0
haxe.crypto.Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe.crypto.Base64.BYTES = haxe.io.Bytes.ofString(haxe.crypto.Base64.CHARS)
http._HttpStatus.HttpStatus_Impl_.Ok = 200
http._HttpStatus.HttpStatus_Impl_.Internal = 500
http._HttpStatus.HttpStatus_Impl_.BadRequest = 400
http._HttpStatus.HttpStatus_Impl_.NotFound = 404
http.handlers.websocket.FrameType.CONTINUE = 0
http.handlers.websocket.FrameType.TEXT = 1
http.handlers.websocket.FrameType.BINARY = 2
http.handlers.websocket.FrameType.CLOSE = 8
http.handlers.websocket.FrameType.PING = 9
http.handlers.websocket.FrameType.PONG = 10
http.handlers.websocket.InternalHandler.MASK_SIZE = 4
http.handlers.websocket.InternalHandler.ONE_BYTE_MAX_BODY_SIZE = 125
http.handlers.websocket.InternalHandler.TWO_BYTE_BODY_SIZE = 126
http.handlers.websocket.InternalHandler.EIGHT_BYTE_BODY_SIZE = 127
http.handlers.websocket.InternalHandler.SecWebSocketKey = "Sec-WebSocket-Key"
http.handlers.websocket.InternalHandler.WS_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
tink._Url.Url_Impl_.SCHEME = 2
tink._Url.Url_Impl_.PAYLOAD = 3
tink._Url.Url_Impl_.AUTH = 6
tink._Url.Url_Impl_.HOSTNAMES = 7
tink._Url.Url_Impl_.PATH = 8
tink._Url.Url_Impl_.QUERY = 10
tink._Url.Url_Impl_.HASH = 12
tink.core.FutureTrigger.depth = 0
tink.url._Path.Path_Impl_.root = (function() 
  local _hx_1
  
  local this1 = "/";
  
  _hx_1 = this1;
  return _hx_1
end )()
zephyr.tag._FormMethodType.FormMethodType_Impl_.post = "post"
zephyr.tag._FormMethodType.FormMethodType_Impl_.get = "get"
zephyr.tag._InputType.InputType_Impl_.button = "button"
zephyr.tag._InputType.InputType_Impl_.file = "file"
zephyr.tag._InputType.InputType_Impl_.hidden = "hidden"
zephyr.tag._InputType.InputType_Impl_.checkbox = "checkbox"
zephyr.tag._InputType.InputType_Impl_.image = "image"
zephyr.tag._InputType.InputType_Impl_.password = "password"
zephyr.tag._InputType.InputType_Impl_.radio = "radio"
zephyr.tag._InputType.InputType_Impl_.reset = "reset"
zephyr.tag._InputType.InputType_Impl_.submit = "submit"
zephyr.tag._InputType.InputType_Impl_.text = "text"
do

if (lua.lib.lrexlib.Rex == nil) then 
  _G.error("Rex is missing.  Please install lrexlib-pcre.",0);
end;
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
chocolate.Chocolate.App = chocolate.Chocolate.new();
chocolate.Chocolate.WebSocket = chocolate.WebSocket.new();
local _g = haxe.ds.StringMap.new();
_g.v["323"] = "text/h323";
_g.k["323"] = true;
_g.v["3dmf"] = "x-world/x-3dmf";
_g.k["3dmf"] = true;
_g.v["3dm"] = "x-world/x-3dmf";
_g.k["3dm"] = true;
_g.v["3g2"] = "video/3gpp2";
_g.k["3g2"] = true;
_g.v["3gp"] = "video/3gpp";
_g.k["3gp"] = true;
_g.v["7z"] = "application/x-7z-compressed";
_g.k["7z"] = true;
_g.v["aab"] = "application/x-authorware-bin";
_g.k["aab"] = true;
_g.v["aac"] = "audio/aac";
_g.k["aac"] = true;
_g.v["aam"] = "application/x-authorware-map";
_g.k["aam"] = true;
_g.v["aas"] = "application/x-authorware-seg";
_g.k["aas"] = true;
_g.v["abc"] = "text/vnd.abc";
_g.k["abc"] = true;
_g.v["acgi"] = "text/html";
_g.k["acgi"] = true;
_g.v["acx"] = "application/internet-property-stream";
_g.k["acx"] = true;
_g.v["afl"] = "video/animaflex";
_g.k["afl"] = true;
_g.v["ai"] = "application/postscript";
_g.k["ai"] = true;
_g.v["aif"] = "audio/aiff";
_g.k["aif"] = true;
_g.v["aifc"] = "audio/aiff";
_g.k["aifc"] = true;
_g.v["aiff"] = "audio/aiff";
_g.k["aiff"] = true;
_g.v["aim"] = "application/x-aim";
_g.k["aim"] = true;
_g.v["aip"] = "text/x-audiosoft-intra";
_g.k["aip"] = true;
_g.v["ani"] = "application/x-navi-animation";
_g.k["ani"] = true;
_g.v["aos"] = "application/x-nokia-9000-communicator-add-on-software";
_g.k["aos"] = true;
_g.v["appcache"] = "text/cache-manifest";
_g.k["appcache"] = true;
_g.v["application"] = "application/x-ms-application";
_g.k["application"] = true;
_g.v["aps"] = "application/mime";
_g.k["aps"] = true;
_g.v["art"] = "image/x-jg";
_g.k["art"] = true;
_g.v["asf"] = "video/x-ms-asf";
_g.k["asf"] = true;
_g.v["asm"] = "text/x-asm";
_g.k["asm"] = true;
_g.v["asp"] = "text/asp";
_g.k["asp"] = true;
_g.v["asr"] = "video/x-ms-asf";
_g.k["asr"] = true;
_g.v["asx"] = "application/x-mplayer2";
_g.k["asx"] = true;
_g.v["atom"] = "application/atom+xml";
_g.k["atom"] = true;
_g.v["au"] = "audio/x-au";
_g.k["au"] = true;
_g.v["avi"] = "video/avi";
_g.k["avi"] = true;
_g.v["avs"] = "video/avs-video";
_g.k["avs"] = true;
_g.v["axs"] = "application/olescript";
_g.k["axs"] = true;
_g.v["bas"] = "text/plain";
_g.k["bas"] = true;
_g.v["bcpio"] = "application/x-bcpio";
_g.k["bcpio"] = true;
_g.v["bin"] = "application/octet-stream";
_g.k["bin"] = true;
_g.v["bm"] = "image/bmp";
_g.k["bm"] = true;
_g.v["bmp"] = "image/bmp";
_g.k["bmp"] = true;
_g.v["boo"] = "application/book";
_g.k["boo"] = true;
_g.v["book"] = "application/book";
_g.k["book"] = true;
_g.v["boz"] = "application/x-bzip2";
_g.k["boz"] = true;
_g.v["bsh"] = "application/x-bsh";
_g.k["bsh"] = true;
_g.v["bz2"] = "application/x-bzip2";
_g.k["bz2"] = true;
_g.v["bz"] = "application/x-bzip";
_g.k["bz"] = true;
_g.v["cat"] = "application/vnd.ms-pki.seccat";
_g.k["cat"] = true;
_g.v["ccad"] = "application/clariscad";
_g.k["ccad"] = true;
_g.v["cco"] = "application/x-cocoa";
_g.k["cco"] = true;
_g.v["cc"] = "text/plain";
_g.k["cc"] = true;
_g.v["cdf"] = "application/cdf";
_g.k["cdf"] = true;
_g.v["cer"] = "application/pkix-cert";
_g.k["cer"] = true;
_g.v["cha"] = "application/x-chat";
_g.k["cha"] = true;
_g.v["chat"] = "application/x-chat";
_g.k["chat"] = true;
_g.v["class"] = "application/x-java-applet";
_g.k["class"] = true;
_g.v["clp"] = "application/x-msclip";
_g.k["clp"] = true;
_g.v["cmx"] = "image/x-cmx";
_g.k["cmx"] = true;
_g.v["cod"] = "image/cis-cod";
_g.k["cod"] = true;
_g.v["coffee"] = "text/x-coffeescript";
_g.k["coffee"] = true;
_g.v["conf"] = "text/plain";
_g.k["conf"] = true;
_g.v["cpio"] = "application/x-cpio";
_g.k["cpio"] = true;
_g.v["cpp"] = "text/plain";
_g.k["cpp"] = true;
_g.v["cpt"] = "application/x-cpt";
_g.k["cpt"] = true;
_g.v["crd"] = "application/x-mscardfile";
_g.k["crd"] = true;
_g.v["crl"] = "application/pkix-crl";
_g.k["crl"] = true;
_g.v["crt"] = "application/pkix-cert";
_g.k["crt"] = true;
_g.v["csh"] = "application/x-csh";
_g.k["csh"] = true;
_g.v["css"] = "text/css";
_g.k["css"] = true;
_g.v["c"] = "text/plain";
_g.k["c"] = true;
_g.v["c++"] = "text/plain";
_g.k["c++"] = true;
_g.v["cxx"] = "text/plain";
_g.k["cxx"] = true;
_g.v["dart"] = "application/dart";
_g.k["dart"] = true;
_g.v["dcr"] = "application/x-director";
_g.k["dcr"] = true;
_g.v["deb"] = "application/x-deb";
_g.k["deb"] = true;
_g.v["deepv"] = "application/x-deepv";
_g.k["deepv"] = true;
_g.v["def"] = "text/plain";
_g.k["def"] = true;
_g.v["deploy"] = "application/octet-stream";
_g.k["deploy"] = true;
_g.v["der"] = "application/x-x509-ca-cert";
_g.k["der"] = true;
_g.v["dib"] = "image/bmp";
_g.k["dib"] = true;
_g.v["dif"] = "video/x-dv";
_g.k["dif"] = true;
_g.v["dir"] = "application/x-director";
_g.k["dir"] = true;
_g.v["disco"] = "text/xml";
_g.k["disco"] = true;
_g.v["dll"] = "application/x-msdownload";
_g.k["dll"] = true;
_g.v["dl"] = "video/dl";
_g.k["dl"] = true;
_g.v["doc"] = "application/msword";
_g.k["doc"] = true;
_g.v["docm"] = "application/vnd.ms-word.document.macroEnabled.12";
_g.k["docm"] = true;
_g.v["docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
_g.k["docx"] = true;
_g.v["dot"] = "application/msword";
_g.k["dot"] = true;
_g.v["dotm"] = "application/vnd.ms-word.template.macroEnabled.12";
_g.k["dotm"] = true;
_g.v["dotx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.template";
_g.k["dotx"] = true;
_g.v["dp"] = "application/commonground";
_g.k["dp"] = true;
_g.v["drw"] = "application/drafting";
_g.k["drw"] = true;
_g.v["dtd"] = "application/xml-dtd";
_g.k["dtd"] = true;
_g.v["dvi"] = "application/x-dvi";
_g.k["dvi"] = true;
_g.v["dv"] = "video/x-dv";
_g.k["dv"] = true;
_g.v["dwf"] = "drawing/x-dwf (old)";
_g.k["dwf"] = true;
_g.v["dwg"] = "application/acad";
_g.k["dwg"] = true;
_g.v["dxf"] = "application/dxf";
_g.k["dxf"] = true;
_g.v["dxr"] = "application/x-director";
_g.k["dxr"] = true;
_g.v["elc"] = "application/x-elc";
_g.k["elc"] = true;
_g.v["el"] = "text/x-script.elisp";
_g.k["el"] = true;
_g.v["eml"] = "message/rfc822";
_g.k["eml"] = true;
_g.v["eot"] = "application/vnd.bw-fontobject";
_g.k["eot"] = true;
_g.v["eps"] = "application/postscript";
_g.k["eps"] = true;
_g.v["es"] = "application/x-esrehber";
_g.k["es"] = true;
_g.v["etx"] = "text/x-setext";
_g.k["etx"] = true;
_g.v["evy"] = "application/envoy";
_g.k["evy"] = true;
_g.v["exe"] = "application/octet-stream";
_g.k["exe"] = true;
_g.v["f77"] = "text/plain";
_g.k["f77"] = true;
_g.v["f90"] = "text/plain";
_g.k["f90"] = true;
_g.v["fdf"] = "application/vnd.fdf";
_g.k["fdf"] = true;
_g.v["fif"] = "image/fif";
_g.k["fif"] = true;
_g.v["flac"] = "audio/x-flac";
_g.k["flac"] = true;
_g.v["fli"] = "video/fli";
_g.k["fli"] = true;
_g.v["flo"] = "image/florian";
_g.k["flo"] = true;
_g.v["flr"] = "x-world/x-vrml";
_g.k["flr"] = true;
_g.v["flx"] = "text/vnd.fmi.flexstor";
_g.k["flx"] = true;
_g.v["fmf"] = "video/x-atomic3d-feature";
_g.k["fmf"] = true;
_g.v["for"] = "text/plain";
_g.k["for"] = true;
_g.v["fpx"] = "image/vnd.fpx";
_g.k["fpx"] = true;
_g.v["frl"] = "application/freeloader";
_g.k["frl"] = true;
_g.v["f"] = "text/plain";
_g.k["f"] = true;
_g.v["funk"] = "audio/make";
_g.k["funk"] = true;
_g.v["g3"] = "image/g3fax";
_g.k["g3"] = true;
_g.v["gif"] = "image/gif";
_g.k["gif"] = true;
_g.v["gl"] = "video/gl";
_g.k["gl"] = true;
_g.v["gsd"] = "audio/x-gsm";
_g.k["gsd"] = true;
_g.v["gsm"] = "audio/x-gsm";
_g.k["gsm"] = true;
_g.v["gsp"] = "application/x-gsp";
_g.k["gsp"] = true;
_g.v["gss"] = "application/x-gss";
_g.k["gss"] = true;
_g.v["gtar"] = "application/x-gtar";
_g.k["gtar"] = true;
_g.v["g"] = "text/plain";
_g.k["g"] = true;
_g.v["gz"] = "application/x-gzip";
_g.k["gz"] = true;
_g.v["gzip"] = "application/x-gzip";
_g.k["gzip"] = true;
_g.v["hdf"] = "application/x-hdf";
_g.k["hdf"] = true;
_g.v["help"] = "application/x-helpfile";
_g.k["help"] = true;
_g.v["hgl"] = "application/vnd.hp-HPGL";
_g.k["hgl"] = true;
_g.v["hh"] = "text/plain";
_g.k["hh"] = true;
_g.v["hlb"] = "text/x-script";
_g.k["hlb"] = true;
_g.v["hlp"] = "application/x-helpfile";
_g.k["hlp"] = true;
_g.v["hpg"] = "application/vnd.hp-HPGL";
_g.k["hpg"] = true;
_g.v["hpgl"] = "application/vnd.hp-HPGL";
_g.k["hpgl"] = true;
_g.v["hqx"] = "application/binhex";
_g.k["hqx"] = true;
_g.v["hta"] = "application/hta";
_g.k["hta"] = true;
_g.v["htc"] = "text/x-component";
_g.k["htc"] = true;
_g.v["h"] = "text/plain";
_g.k["h"] = true;
_g.v["htmls"] = "text/html";
_g.k["htmls"] = true;
_g.v["html"] = "text/html";
_g.k["html"] = true;
_g.v["htm"] = "text/html";
_g.k["htm"] = true;
_g.v["htt"] = "text/webviewhtml";
_g.k["htt"] = true;
_g.v["htx"] = "text/html";
_g.k["htx"] = true;
_g.v["ice"] = "x-conference/x-cooltalk";
_g.k["ice"] = true;
_g.v["ico"] = "image/x-icon";
_g.k["ico"] = true;
_g.v["ics"] = "text/calendar";
_g.k["ics"] = true;
_g.v["idc"] = "text/plain";
_g.k["idc"] = true;
_g.v["ief"] = "image/ief";
_g.k["ief"] = true;
_g.v["iefs"] = "image/ief";
_g.k["iefs"] = true;
_g.v["iges"] = "application/iges";
_g.k["iges"] = true;
_g.v["igs"] = "application/iges";
_g.k["igs"] = true;
_g.v["iii"] = "application/x-iphone";
_g.k["iii"] = true;
_g.v["ima"] = "application/x-ima";
_g.k["ima"] = true;
_g.v["imap"] = "application/x-httpd-imap";
_g.k["imap"] = true;
_g.v["inf"] = "application/inf";
_g.k["inf"] = true;
_g.v["ins"] = "application/x-internett-signup";
_g.k["ins"] = true;
_g.v["ip"] = "application/x-ip2";
_g.k["ip"] = true;
_g.v["isp"] = "application/x-internet-signup";
_g.k["isp"] = true;
_g.v["isu"] = "video/x-isvideo";
_g.k["isu"] = true;
_g.v["it"] = "audio/it";
_g.k["it"] = true;
_g.v["iv"] = "application/x-inventor";
_g.k["iv"] = true;
_g.v["ivf"] = "video/x-ivf";
_g.k["ivf"] = true;
_g.v["ivr"] = "i-world/i-vrml";
_g.k["ivr"] = true;
_g.v["ivy"] = "application/x-livescreen";
_g.k["ivy"] = true;
_g.v["jam"] = "audio/x-jam";
_g.k["jam"] = true;
_g.v["jar"] = "application/java-archive";
_g.k["jar"] = true;
_g.v["java"] = "text/plain";
_g.k["java"] = true;
_g.v["jav"] = "text/plain";
_g.k["jav"] = true;
_g.v["jcm"] = "application/x-java-commerce";
_g.k["jcm"] = true;
_g.v["jfif"] = "image/jpeg";
_g.k["jfif"] = true;
_g.v["jfif-tbnl"] = "image/jpeg";
_g.k["jfif-tbnl"] = true;
_g.v["jpeg"] = "image/jpeg";
_g.k["jpeg"] = true;
_g.v["jpe"] = "image/jpeg";
_g.k["jpe"] = true;
_g.v["jpg"] = "image/jpeg";
_g.k["jpg"] = true;
_g.v["jps"] = "image/x-jps";
_g.k["jps"] = true;
_g.v["js"] = "application/javascript";
_g.k["js"] = true;
_g.v["json"] = "application/json";
_g.k["json"] = true;
_g.v["jut"] = "image/jutvision";
_g.k["jut"] = true;
_g.v["kar"] = "audio/midi";
_g.k["kar"] = true;
_g.v["ksh"] = "text/x-script.ksh";
_g.k["ksh"] = true;
_g.v["la"] = "audio/nspaudio";
_g.k["la"] = true;
_g.v["lam"] = "audio/x-liveaudio";
_g.k["lam"] = true;
_g.v["latex"] = "application/x-latex";
_g.k["latex"] = true;
_g.v["list"] = "text/plain";
_g.k["list"] = true;
_g.v["lma"] = "audio/nspaudio";
_g.k["lma"] = true;
_g.v["log"] = "text/plain";
_g.k["log"] = true;
_g.v["lsp"] = "application/x-lisp";
_g.k["lsp"] = true;
_g.v["lst"] = "text/plain";
_g.k["lst"] = true;
_g.v["lsx"] = "text/x-la-asf";
_g.k["lsx"] = true;
_g.v["ltx"] = "application/x-latex";
_g.k["ltx"] = true;
_g.v["m13"] = "application/x-msmediaview";
_g.k["m13"] = true;
_g.v["m14"] = "application/x-msmediaview";
_g.k["m14"] = true;
_g.v["m1v"] = "video/mpeg";
_g.k["m1v"] = true;
_g.v["m2a"] = "audio/mpeg";
_g.k["m2a"] = true;
_g.v["m2v"] = "video/mpeg";
_g.k["m2v"] = true;
_g.v["m3u"] = "audio/x-mpequrl";
_g.k["m3u"] = true;
_g.v["m4a"] = "audio/mp4";
_g.k["m4a"] = true;
_g.v["m4v"] = "video/mp4";
_g.k["m4v"] = true;
_g.v["man"] = "application/x-troff-man";
_g.k["man"] = true;
_g.v["manifest"] = "application/x-ms-manifest";
_g.k["manifest"] = true;
_g.v["map"] = "application/x-navimap";
_g.k["map"] = true;
_g.v["mar"] = "text/plain";
_g.k["mar"] = true;
_g.v["mbd"] = "application/mbedlet";
_g.k["mbd"] = true;
_g.v["mc$"] = "application/x-magic-cap-package-1.0";
_g.k["mc$"] = true;
_g.v["mcd"] = "application/mcad";
_g.k["mcd"] = true;
_g.v["mcf"] = "image/vasa";
_g.k["mcf"] = true;
_g.v["mcp"] = "application/netmc";
_g.k["mcp"] = true;
_g.v["mdb"] = "application/x-msaccess";
_g.k["mdb"] = true;
_g.v["mesh"] = "model/mesh";
_g.k["mesh"] = true;
_g.v["me"] = "application/x-troff-me";
_g.k["me"] = true;
_g.v["mid"] = "audio/midi";
_g.k["mid"] = true;
_g.v["midi"] = "audio/midi";
_g.k["midi"] = true;
_g.v["mif"] = "application/x-mif";
_g.k["mif"] = true;
_g.v["mjf"] = "audio/x-vnd.AudioExplosion.MjuiceMediaFile";
_g.k["mjf"] = true;
_g.v["mjpg"] = "video/x-motion-jpeg";
_g.k["mjpg"] = true;
_g.v["mm"] = "application/base64";
_g.k["mm"] = true;
_g.v["mme"] = "application/base64";
_g.k["mme"] = true;
_g.v["mny"] = "application/x-msmoney";
_g.k["mny"] = true;
_g.v["mod"] = "audio/mod";
_g.k["mod"] = true;
_g.v["mov"] = "video/quicktime";
_g.k["mov"] = true;
_g.v["movie"] = "video/x-sgi-movie";
_g.k["movie"] = true;
_g.v["mp2"] = "video/mpeg";
_g.k["mp2"] = true;
_g.v["mp3"] = "audio/mpeg";
_g.k["mp3"] = true;
_g.v["mp4"] = "video/mp4";
_g.k["mp4"] = true;
_g.v["mp4a"] = "audio/mp4";
_g.k["mp4a"] = true;
_g.v["mp4v"] = "video/mp4";
_g.k["mp4v"] = true;
_g.v["mpa"] = "audio/mpeg";
_g.k["mpa"] = true;
_g.v["mpc"] = "application/x-project";
_g.k["mpc"] = true;
_g.v["mpeg"] = "video/mpeg";
_g.k["mpeg"] = true;
_g.v["mpe"] = "video/mpeg";
_g.k["mpe"] = true;
_g.v["mpga"] = "audio/mpeg";
_g.k["mpga"] = true;
_g.v["mpg"] = "video/mpeg";
_g.k["mpg"] = true;
_g.v["mpp"] = "application/vnd.ms-project";
_g.k["mpp"] = true;
_g.v["mpt"] = "application/x-project";
_g.k["mpt"] = true;
_g.v["mpv2"] = "video/mpeg";
_g.k["mpv2"] = true;
_g.v["mpv"] = "application/x-project";
_g.k["mpv"] = true;
_g.v["mpx"] = "application/x-project";
_g.k["mpx"] = true;
_g.v["mrc"] = "application/marc";
_g.k["mrc"] = true;
_g.v["ms"] = "application/x-troff-ms";
_g.k["ms"] = true;
_g.v["msh"] = "model/mesh";
_g.k["msh"] = true;
_g.v["m"] = "text/plain";
_g.k["m"] = true;
_g.v["mvb"] = "application/x-msmediaview";
_g.k["mvb"] = true;
_g.v["mv"] = "video/x-sgi-movie";
_g.k["mv"] = true;
_g.v["my"] = "audio/make";
_g.k["my"] = true;
_g.v["mzz"] = "application/x-vnd.AudioExplosion.mzz";
_g.k["mzz"] = true;
_g.v["nap"] = "image/naplps";
_g.k["nap"] = true;
_g.v["naplps"] = "image/naplps";
_g.k["naplps"] = true;
_g.v["nc"] = "application/x-netcdf";
_g.k["nc"] = true;
_g.v["ncm"] = "application/vnd.nokia.configuration-message";
_g.k["ncm"] = true;
_g.v["niff"] = "image/x-niff";
_g.k["niff"] = true;
_g.v["nif"] = "image/x-niff";
_g.k["nif"] = true;
_g.v["nix"] = "application/x-mix-transfer";
_g.k["nix"] = true;
_g.v["nsc"] = "application/x-conference";
_g.k["nsc"] = true;
_g.v["nvd"] = "application/x-navidoc";
_g.k["nvd"] = true;
_g.v["nws"] = "message/rfc822";
_g.k["nws"] = true;
_g.v["oda"] = "application/oda";
_g.k["oda"] = true;
_g.v["ods"] = "application/oleobject";
_g.k["ods"] = true;
_g.v["oga"] = "audio/ogg";
_g.k["oga"] = true;
_g.v["ogg"] = "audio/ogg";
_g.k["ogg"] = true;
_g.v["ogv"] = "video/ogg";
_g.k["ogv"] = true;
_g.v["ogx"] = "application/ogg";
_g.k["ogx"] = true;
_g.v["omc"] = "application/x-omc";
_g.k["omc"] = true;
_g.v["omcd"] = "application/x-omcdatamaker";
_g.k["omcd"] = true;
_g.v["omcr"] = "application/x-omcregerator";
_g.k["omcr"] = true;
_g.v["opus"] = "audio/ogg";
_g.k["opus"] = true;
_g.v["oxps"] = "application/oxps";
_g.k["oxps"] = true;
_g.v["p10"] = "application/pkcs10";
_g.k["p10"] = true;
_g.v["p12"] = "application/pkcs-12";
_g.k["p12"] = true;
_g.v["p7a"] = "application/x-pkcs7-signature";
_g.k["p7a"] = true;
_g.v["p7b"] = "application/x-pkcs7-certificates";
_g.k["p7b"] = true;
_g.v["p7c"] = "application/pkcs7-mime";
_g.k["p7c"] = true;
_g.v["p7m"] = "application/pkcs7-mime";
_g.k["p7m"] = true;
_g.v["p7r"] = "application/x-pkcs7-certreqresp";
_g.k["p7r"] = true;
_g.v["p7s"] = "application/pkcs7-signature";
_g.k["p7s"] = true;
_g.v["part"] = "application/pro_eng";
_g.k["part"] = true;
_g.v["pas"] = "text/pascal";
_g.k["pas"] = true;
_g.v["pbm"] = "image/x-portable-bitmap";
_g.k["pbm"] = true;
_g.v["pcl"] = "application/x-pcl";
_g.k["pcl"] = true;
_g.v["pct"] = "image/x-pict";
_g.k["pct"] = true;
_g.v["pcx"] = "image/x-pcx";
_g.k["pcx"] = true;
_g.v["pdb"] = "chemical/x-pdb";
_g.k["pdb"] = true;
_g.v["pdf"] = "application/pdf";
_g.k["pdf"] = true;
_g.v["pfunk"] = "audio/make";
_g.k["pfunk"] = true;
_g.v["pfx"] = "application/x-pkcs12";
_g.k["pfx"] = true;
_g.v["pgm"] = "image/x-portable-graymap";
_g.k["pgm"] = true;
_g.v["pic"] = "image/pict";
_g.k["pic"] = true;
_g.v["pict"] = "image/pict";
_g.k["pict"] = true;
_g.v["pkg"] = "application/x-newton-compatible-pkg";
_g.k["pkg"] = true;
_g.v["pko"] = "application/vnd.ms-pki.pko";
_g.k["pko"] = true;
_g.v["pl"] = "text/plain";
_g.k["pl"] = true;
_g.v["plx"] = "application/x-PiXCLscript";
_g.k["plx"] = true;
_g.v["pm4"] = "application/x-pagemaker";
_g.k["pm4"] = true;
_g.v["pm5"] = "application/x-pagemaker";
_g.k["pm5"] = true;
_g.v["pma"] = "application/x-perfmon";
_g.k["pma"] = true;
_g.v["pmc"] = "application/x-perfmon";
_g.k["pmc"] = true;
_g.v["pm"] = "image/x-xpixmap";
_g.k["pm"] = true;
_g.v["pml"] = "application/x-perfmon";
_g.k["pml"] = true;
_g.v["pmr"] = "application/x-perfmon";
_g.k["pmr"] = true;
_g.v["pmw"] = "application/x-perfmon";
_g.k["pmw"] = true;
_g.v["png"] = "image/png";
_g.k["png"] = true;
_g.v["pnm"] = "application/x-portable-anymap";
_g.k["pnm"] = true;
_g.v["pot"] = "application/vnd.ms-powerpoint";
_g.k["pot"] = true;
_g.v["potm"] = "application/vnd.ms-powerpoint.template.macroEnabled.12";
_g.k["potm"] = true;
_g.v["potx"] = "application/vnd.openxmlformats-officedocument.presentationml.template";
_g.k["potx"] = true;
_g.v["pov"] = "model/x-pov";
_g.k["pov"] = true;
_g.v["ppa"] = "application/vnd.ms-powerpoint";
_g.k["ppa"] = true;
_g.v["ppam"] = "application/vnd.ms-powerpoint.setin.macroEnabled.12";
_g.k["ppam"] = true;
_g.v["ppm"] = "image/x-portable-pixmap";
_g.k["ppm"] = true;
_g.v["pps"] = "application/vnd.ms-powerpoint";
_g.k["pps"] = true;
_g.v["ppsm"] = "application/vnd.ms-powerpoint.slideshow.macroEnabled.12";
_g.k["ppsm"] = true;
_g.v["ppsx"] = "application/vnd.openxmlformats-officedocument.presentationml.slideshow";
_g.k["ppsx"] = true;
_g.v["ppt"] = "application/vnd.ms-powerpoint";
_g.k["ppt"] = true;
_g.v["pptm"] = "application/vnd.ms-powerpoint.presentation.macroEnabled.12";
_g.k["pptm"] = true;
_g.v["pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
_g.k["pptx"] = true;
_g.v["ppz"] = "application/mspowerpoint";
_g.k["ppz"] = true;
_g.v["pre"] = "application/x-freelance";
_g.k["pre"] = true;
_g.v["prf"] = "application/pics-rules";
_g.k["prf"] = true;
_g.v["prt"] = "application/pro_eng";
_g.k["prt"] = true;
_g.v["ps"] = "application/postscript";
_g.k["ps"] = true;
_g.v["p"] = "text/x-pascal";
_g.k["p"] = true;
_g.v["pub"] = "application/x-mspublisher";
_g.k["pub"] = true;
_g.v["pvu"] = "paleovu/x-pv";
_g.k["pvu"] = true;
_g.v["pwz"] = "application/vnd.ms-powerpoint";
_g.k["pwz"] = true;
_g.v["pyc"] = "applicaiton/x-bytecode.python";
_g.k["pyc"] = true;
_g.v["py"] = "text/x-script.phyton";
_g.k["py"] = true;
_g.v["qcp"] = "audio/vnd.qcelp";
_g.k["qcp"] = true;
_g.v["qd3d"] = "x-world/x-3dmf";
_g.k["qd3d"] = true;
_g.v["qd3"] = "x-world/x-3dmf";
_g.k["qd3"] = true;
_g.v["qif"] = "image/x-quicktime";
_g.k["qif"] = true;
_g.v["qtc"] = "video/x-qtc";
_g.k["qtc"] = true;
_g.v["qtif"] = "image/x-quicktime";
_g.k["qtif"] = true;
_g.v["qti"] = "image/x-quicktime";
_g.k["qti"] = true;
_g.v["qt"] = "video/quicktime";
_g.k["qt"] = true;
_g.v["ra"] = "audio/x-pn-realaudio";
_g.k["ra"] = true;
_g.v["ram"] = "audio/x-pn-realaudio";
_g.k["ram"] = true;
_g.v["ras"] = "application/x-cmu-raster";
_g.k["ras"] = true;
_g.v["rast"] = "image/cmu-raster";
_g.k["rast"] = true;
_g.v["rexx"] = "text/x-script.rexx";
_g.k["rexx"] = true;
_g.v["rf"] = "image/vnd.rn-realflash";
_g.k["rf"] = true;
_g.v["rgb"] = "image/x-rgb";
_g.k["rgb"] = true;
_g.v["rm"] = "application/vnd.rn-realmedia";
_g.k["rm"] = true;
_g.v["rmi"] = "audio/mid";
_g.k["rmi"] = true;
_g.v["rmm"] = "audio/x-pn-realaudio";
_g.k["rmm"] = true;
_g.v["rmp"] = "audio/x-pn-realaudio";
_g.k["rmp"] = true;
_g.v["rng"] = "application/ringing-tones";
_g.k["rng"] = true;
_g.v["rnx"] = "application/vnd.rn-realplayer";
_g.k["rnx"] = true;
_g.v["roff"] = "application/x-troff";
_g.k["roff"] = true;
_g.v["rp"] = "image/vnd.rn-realpix";
_g.k["rp"] = true;
_g.v["rpm"] = "audio/x-pn-realaudio-plugin";
_g.k["rpm"] = true;
_g.v["rss"] = "application/rss+xml";
_g.k["rss"] = true;
_g.v["rtf"] = "text/richtext";
_g.k["rtf"] = true;
_g.v["rt"] = "text/richtext";
_g.k["rt"] = true;
_g.v["rtx"] = "text/richtext";
_g.k["rtx"] = true;
_g.v["rv"] = "video/vnd.rn-realvideo";
_g.k["rv"] = true;
_g.v["s3m"] = "audio/s3m";
_g.k["s3m"] = true;
_g.v["sbk"] = "application/x-tbook";
_g.k["sbk"] = true;
_g.v["scd"] = "application/x-msschedule";
_g.k["scd"] = true;
_g.v["scm"] = "application/x-lotusscreencam";
_g.k["scm"] = true;
_g.v["sct"] = "text/scriptlet";
_g.k["sct"] = true;
_g.v["sdml"] = "text/plain";
_g.k["sdml"] = true;
_g.v["sdp"] = "application/sdp";
_g.k["sdp"] = true;
_g.v["sdr"] = "application/sounder";
_g.k["sdr"] = true;
_g.v["sea"] = "application/sea";
_g.k["sea"] = true;
_g.v["set"] = "application/set";
_g.k["set"] = true;
_g.v["setpay"] = "application/set-payment-initiation";
_g.k["setpay"] = true;
_g.v["setreg"] = "application/set-registration-initiation";
_g.k["setreg"] = true;
_g.v["sgml"] = "text/sgml";
_g.k["sgml"] = true;
_g.v["sgm"] = "text/sgml";
_g.k["sgm"] = true;
_g.v["shar"] = "application/x-bsh";
_g.k["shar"] = true;
_g.v["sh"] = "text/x-script.sh";
_g.k["sh"] = true;
_g.v["shtml"] = "text/html";
_g.k["shtml"] = true;
_g.v["sid"] = "audio/x-psid";
_g.k["sid"] = true;
_g.v["silo"] = "model/mesh";
_g.k["silo"] = true;
_g.v["sit"] = "application/x-sit";
_g.k["sit"] = true;
_g.v["skd"] = "application/x-koan";
_g.k["skd"] = true;
_g.v["skm"] = "application/x-koan";
_g.k["skm"] = true;
_g.v["skp"] = "application/x-koan";
_g.k["skp"] = true;
_g.v["skt"] = "application/x-koan";
_g.k["skt"] = true;
_g.v["sl"] = "application/x-seelogo";
_g.k["sl"] = true;
_g.v["smi"] = "application/smil";
_g.k["smi"] = true;
_g.v["smil"] = "application/smil";
_g.k["smil"] = true;
_g.v["snd"] = "audio/basic";
_g.k["snd"] = true;
_g.v["sol"] = "application/solids";
_g.k["sol"] = true;
_g.v["spc"] = "application/x-pkcs7-certificates";
_g.k["spc"] = true;
_g.v["spl"] = "application/futuresplash";
_g.k["spl"] = true;
_g.v["spr"] = "application/x-sprite";
_g.k["spr"] = true;
_g.v["sprite"] = "application/x-sprite";
_g.k["sprite"] = true;
_g.v["spx"] = "audio/ogg";
_g.k["spx"] = true;
_g.v["src"] = "application/x-wais-source";
_g.k["src"] = true;
_g.v["ssi"] = "text/x-server-parsed-html";
_g.k["ssi"] = true;
_g.v["ssm"] = "application/streamingmedia";
_g.k["ssm"] = true;
_g.v["sst"] = "application/vnd.ms-pki.certstore";
_g.k["sst"] = true;
_g.v["step"] = "application/step";
_g.k["step"] = true;
_g.v["s"] = "text/x-asm";
_g.k["s"] = true;
_g.v["stl"] = "application/sla";
_g.k["stl"] = true;
_g.v["stm"] = "text/html";
_g.k["stm"] = true;
_g.v["stp"] = "application/step";
_g.k["stp"] = true;
_g.v["sv4cpio"] = "application/x-sv4cpio";
_g.k["sv4cpio"] = true;
_g.v["sv4crc"] = "application/x-sv4crc";
_g.k["sv4crc"] = true;
_g.v["svf"] = "image/x-dwg";
_g.k["svf"] = true;
_g.v["svg"] = "image/svg+xml";
_g.k["svg"] = true;
_g.v["svr"] = "application/x-world";
_g.k["svr"] = true;
_g.v["swf"] = "application/x-shockwave-flash";
_g.k["swf"] = true;
_g.v["talk"] = "text/x-speech";
_g.k["talk"] = true;
_g.v["t"] = "application/x-troff";
_g.k["t"] = true;
_g.v["tar"] = "application/x-tar";
_g.k["tar"] = true;
_g.v["tbk"] = "application/toolbook";
_g.k["tbk"] = true;
_g.v["tcl"] = "text/x-script.tcl";
_g.k["tcl"] = true;
_g.v["tcsh"] = "text/x-script.tcsh";
_g.k["tcsh"] = true;
_g.v["tex"] = "application/x-tex";
_g.k["tex"] = true;
_g.v["texi"] = "application/x-texinfo";
_g.k["texi"] = true;
_g.v["texinfo"] = "application/x-texinfo";
_g.k["texinfo"] = true;
_g.v["text"] = "text/plain";
_g.k["text"] = true;
_g.v["tgz"] = "application/x-compressed";
_g.k["tgz"] = true;
_g.v["tiff"] = "image/tiff";
_g.k["tiff"] = true;
_g.v["tif"] = "image/tiff";
_g.k["tif"] = true;
_g.v["tr"] = "application/x-troff";
_g.k["tr"] = true;
_g.v["trm"] = "application/x-msterminal";
_g.k["trm"] = true;
_g.v["ts"] = "text/x-typescript";
_g.k["ts"] = true;
_g.v["tsi"] = "audio/tsp-audio";
_g.k["tsi"] = true;
_g.v["tsp"] = "audio/tsplayer";
_g.k["tsp"] = true;
_g.v["tsv"] = "text/tab-separated-values";
_g.k["tsv"] = true;
_g.v["ttf"] = "application/x-font-ttf";
_g.k["ttf"] = true;
_g.v["turbot"] = "image/florian";
_g.k["turbot"] = true;
_g.v["txt"] = "text/plain";
_g.k["txt"] = true;
_g.v["uil"] = "text/x-uil";
_g.k["uil"] = true;
_g.v["uls"] = "text/iuls";
_g.k["uls"] = true;
_g.v["unis"] = "text/uri-list";
_g.k["unis"] = true;
_g.v["uni"] = "text/uri-list";
_g.k["uni"] = true;
_g.v["unv"] = "application/i-deas";
_g.k["unv"] = true;
_g.v["uris"] = "text/uri-list";
_g.k["uris"] = true;
_g.v["uri"] = "text/uri-list";
_g.k["uri"] = true;
_g.v["ustar"] = "multipart/x-ustar";
_g.k["ustar"] = true;
_g.v["uue"] = "text/x-uuencode";
_g.k["uue"] = true;
_g.v["uu"] = "text/x-uuencode";
_g.k["uu"] = true;
_g.v["vcd"] = "application/x-cdlink";
_g.k["vcd"] = true;
_g.v["vcf"] = "text/vcard";
_g.k["vcf"] = true;
_g.v["vcard"] = "text/vcard";
_g.k["vcard"] = true;
_g.v["vcs"] = "text/x-vCalendar";
_g.k["vcs"] = true;
_g.v["vda"] = "application/vda";
_g.k["vda"] = true;
_g.v["vdo"] = "video/vdo";
_g.k["vdo"] = true;
_g.v["vew"] = "application/groupwise";
_g.k["vew"] = true;
_g.v["vivo"] = "video/vivo";
_g.k["vivo"] = true;
_g.v["viv"] = "video/vivo";
_g.k["viv"] = true;
_g.v["vmd"] = "application/vocaltec-media-desc";
_g.k["vmd"] = true;
_g.v["vmf"] = "application/vocaltec-media-file";
_g.k["vmf"] = true;
_g.v["voc"] = "audio/voc";
_g.k["voc"] = true;
_g.v["vos"] = "video/vosaic";
_g.k["vos"] = true;
_g.v["vox"] = "audio/voxware";
_g.k["vox"] = true;
_g.v["vqe"] = "audio/x-twinvq-plugin";
_g.k["vqe"] = true;
_g.v["vqf"] = "audio/x-twinvq";
_g.k["vqf"] = true;
_g.v["vql"] = "audio/x-twinvq-plugin";
_g.k["vql"] = true;
_g.v["vrml"] = "application/x-vrml";
_g.k["vrml"] = true;
_g.v["vrt"] = "x-world/x-vrt";
_g.k["vrt"] = true;
_g.v["vsd"] = "application/x-visio";
_g.k["vsd"] = true;
_g.v["vst"] = "application/x-visio";
_g.k["vst"] = true;
_g.v["vsw"] = "application/x-visio";
_g.k["vsw"] = true;
_g.v["w60"] = "application/wordperfect6.0";
_g.k["w60"] = true;
_g.v["w61"] = "application/wordperfect6.1";
_g.k["w61"] = true;
_g.v["w6w"] = "application/msword";
_g.k["w6w"] = true;
_g.v["wav"] = "audio/wav";
_g.k["wav"] = true;
_g.v["wb1"] = "application/x-qpro";
_g.k["wb1"] = true;
_g.v["wbmp"] = "image/vnd.wap.wbmp";
_g.k["wbmp"] = true;
_g.v["wcm"] = "application/vnd.ms-works";
_g.k["wcm"] = true;
_g.v["wdb"] = "application/vnd.ms-works";
_g.k["wdb"] = true;
_g.v["web"] = "application/vnd.xara";
_g.k["web"] = true;
_g.v["webm"] = "video/webm";
_g.k["webm"] = true;
_g.v["wiz"] = "application/msword";
_g.k["wiz"] = true;
_g.v["wk1"] = "application/x-123";
_g.k["wk1"] = true;
_g.v["wks"] = "application/vnd.ms-works";
_g.k["wks"] = true;
_g.v["wmf"] = "windows/metafile";
_g.k["wmf"] = true;
_g.v["wmlc"] = "application/vnd.wap.wmlc";
_g.k["wmlc"] = true;
_g.v["wmlsc"] = "application/vnd.wap.wmlscriptc";
_g.k["wmlsc"] = true;
_g.v["wmls"] = "text/vnd.wap.wmlscript";
_g.k["wmls"] = true;
_g.v["wml"] = "text/vnd.wap.wml";
_g.k["wml"] = true;
_g.v["wmp"] = "video/x-ms-wmp";
_g.k["wmp"] = true;
_g.v["wmv"] = "video/x-ms-wmv";
_g.k["wmv"] = true;
_g.v["wmx"] = "video/x-ms-wmx";
_g.k["wmx"] = true;
_g.v["woff"] = "application/x-woff";
_g.k["woff"] = true;
_g.v["word"] = "application/msword";
_g.k["word"] = true;
_g.v["wp5"] = "application/wordperfect";
_g.k["wp5"] = true;
_g.v["wp6"] = "application/wordperfect";
_g.k["wp6"] = true;
_g.v["wp"] = "application/wordperfect";
_g.k["wp"] = true;
_g.v["wpd"] = "application/wordperfect";
_g.k["wpd"] = true;
_g.v["wps"] = "application/vnd.ms-works";
_g.k["wps"] = true;
_g.v["wq1"] = "application/x-lotus";
_g.k["wq1"] = true;
_g.v["wri"] = "application/mswrite";
_g.k["wri"] = true;
_g.v["wrl"] = "application/x-world";
_g.k["wrl"] = true;
_g.v["wrz"] = "model/vrml";
_g.k["wrz"] = true;
_g.v["wsc"] = "text/scriplet";
_g.k["wsc"] = true;
_g.v["wsdl"] = "text/xml";
_g.k["wsdl"] = true;
_g.v["wsrc"] = "application/x-wais-source";
_g.k["wsrc"] = true;
_g.v["wtk"] = "application/x-wintalk";
_g.k["wtk"] = true;
_g.v["wvx"] = "video/x-ms-wvx";
_g.k["wvx"] = true;
_g.v["x3d"] = "model/x3d+xml";
_g.k["x3d"] = true;
_g.v["x3db"] = "model/x3d+fastinfoset";
_g.k["x3db"] = true;
_g.v["x3dv"] = "model/x3d-vrml";
_g.k["x3dv"] = true;
_g.v["xaf"] = "x-world/x-vrml";
_g.k["xaf"] = true;
_g.v["xaml"] = "application/xaml+xml";
_g.k["xaml"] = true;
_g.v["xap"] = "application/x-silverlight-app";
_g.k["xap"] = true;
_g.v["xbap"] = "application/x-ms-xbap";
_g.k["xbap"] = true;
_g.v["xbm"] = "image/x-xbitmap";
_g.k["xbm"] = true;
_g.v["xdr"] = "video/x-amt-demorun";
_g.k["xdr"] = true;
_g.v["xgz"] = "xgl/drawing";
_g.k["xgz"] = true;
_g.v["xht"] = "application/xhtml+xml";
_g.k["xht"] = true;
_g.v["xhtml"] = "application/xhtml+xml";
_g.k["xhtml"] = true;
_g.v["xif"] = "image/vnd.xiff";
_g.k["xif"] = true;
_g.v["xla"] = "application/vnd.ms-excel";
_g.k["xla"] = true;
_g.v["xlam"] = "application/vnd.ms-excel.setin.macroEnabled.12";
_g.k["xlam"] = true;
_g.v["xl"] = "application/excel";
_g.k["xl"] = true;
_g.v["xlb"] = "application/excel";
_g.k["xlb"] = true;
_g.v["xlc"] = "application/excel";
_g.k["xlc"] = true;
_g.v["xld"] = "application/excel";
_g.k["xld"] = true;
_g.v["xlk"] = "application/excel";
_g.k["xlk"] = true;
_g.v["xll"] = "application/excel";
_g.k["xll"] = true;
_g.v["xlm"] = "application/excel";
_g.k["xlm"] = true;
_g.v["xls"] = "application/vnd.ms-excel";
_g.k["xls"] = true;
_g.v["xlsb"] = "application/vnd.ms-excel.sheet.binary.macroEnabled.12";
_g.k["xlsb"] = true;
_g.v["xlsm"] = "application/vnd.ms-excel.sheet.macroEnabled.12";
_g.k["xlsm"] = true;
_g.v["xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
_g.k["xlsx"] = true;
_g.v["xlt"] = "application/vnd.ms-excel";
_g.k["xlt"] = true;
_g.v["xltm"] = "application/vnd.ms-excel.template.macroEnabled.12";
_g.k["xltm"] = true;
_g.v["xltx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.template";
_g.k["xltx"] = true;
_g.v["xlv"] = "application/excel";
_g.k["xlv"] = true;
_g.v["xlw"] = "application/excel";
_g.k["xlw"] = true;
_g.v["xm"] = "audio/xm";
_g.k["xm"] = true;
_g.v["xml"] = "text/xml";
_g.k["xml"] = true;
_g.v["xmz"] = "xgl/movie";
_g.k["xmz"] = true;
_g.v["xof"] = "x-world/x-vrml";
_g.k["xof"] = true;
_g.v["xpi"] = "application/x-xpinstall";
_g.k["xpi"] = true;
_g.v["xpix"] = "application/x-vnd.ls-xpix";
_g.k["xpix"] = true;
_g.v["xpm"] = "image/xpm";
_g.k["xpm"] = true;
_g.v["xps"] = "application/vnd.ms-xpsdocument";
_g.k["xps"] = true;
_g.v["x-png"] = "image/png";
_g.k["x-png"] = true;
_g.v["xsd"] = "text/xml";
_g.k["xsd"] = true;
_g.v["xsl"] = "text/xml";
_g.k["xsl"] = true;
_g.v["xslt"] = "text/xml";
_g.k["xslt"] = true;
_g.v["xsr"] = "video/x-amt-showrun";
_g.k["xsr"] = true;
_g.v["xwd"] = "image/x-xwd";
_g.k["xwd"] = true;
_g.v["xyz"] = "chemical/x-pdb";
_g.k["xyz"] = true;
_g.v["z"] = "application/x-compressed";
_g.k["z"] = true;
_g.v["zip"] = "application/zip";
_g.k["zip"] = true;
_g.v["zsh"] = "text/x-script.zsh";
_g.k["zsh"] = true;
mime.MimeTypes.mimeTypes = _g;
if (lua.lib.lrexlib.Rex == nil) then 
  _G.error("Rex is missing.  Please install lrexlib-pcre.",0);
end;
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
chocolate.Chocolate.App = chocolate.Chocolate.new();
chocolate.Chocolate.WebSocket = chocolate.WebSocket.new();
local _g = haxe.ds.StringMap.new();
_g.v["323"] = "text/h323";
_g.k["323"] = true;
_g.v["3dmf"] = "x-world/x-3dmf";
_g.k["3dmf"] = true;
_g.v["3dm"] = "x-world/x-3dmf";
_g.k["3dm"] = true;
_g.v["3g2"] = "video/3gpp2";
_g.k["3g2"] = true;
_g.v["3gp"] = "video/3gpp";
_g.k["3gp"] = true;
_g.v["7z"] = "application/x-7z-compressed";
_g.k["7z"] = true;
_g.v["aab"] = "application/x-authorware-bin";
_g.k["aab"] = true;
_g.v["aac"] = "audio/aac";
_g.k["aac"] = true;
_g.v["aam"] = "application/x-authorware-map";
_g.k["aam"] = true;
_g.v["aas"] = "application/x-authorware-seg";
_g.k["aas"] = true;
_g.v["abc"] = "text/vnd.abc";
_g.k["abc"] = true;
_g.v["acgi"] = "text/html";
_g.k["acgi"] = true;
_g.v["acx"] = "application/internet-property-stream";
_g.k["acx"] = true;
_g.v["afl"] = "video/animaflex";
_g.k["afl"] = true;
_g.v["ai"] = "application/postscript";
_g.k["ai"] = true;
_g.v["aif"] = "audio/aiff";
_g.k["aif"] = true;
_g.v["aifc"] = "audio/aiff";
_g.k["aifc"] = true;
_g.v["aiff"] = "audio/aiff";
_g.k["aiff"] = true;
_g.v["aim"] = "application/x-aim";
_g.k["aim"] = true;
_g.v["aip"] = "text/x-audiosoft-intra";
_g.k["aip"] = true;
_g.v["ani"] = "application/x-navi-animation";
_g.k["ani"] = true;
_g.v["aos"] = "application/x-nokia-9000-communicator-add-on-software";
_g.k["aos"] = true;
_g.v["appcache"] = "text/cache-manifest";
_g.k["appcache"] = true;
_g.v["application"] = "application/x-ms-application";
_g.k["application"] = true;
_g.v["aps"] = "application/mime";
_g.k["aps"] = true;
_g.v["art"] = "image/x-jg";
_g.k["art"] = true;
_g.v["asf"] = "video/x-ms-asf";
_g.k["asf"] = true;
_g.v["asm"] = "text/x-asm";
_g.k["asm"] = true;
_g.v["asp"] = "text/asp";
_g.k["asp"] = true;
_g.v["asr"] = "video/x-ms-asf";
_g.k["asr"] = true;
_g.v["asx"] = "application/x-mplayer2";
_g.k["asx"] = true;
_g.v["atom"] = "application/atom+xml";
_g.k["atom"] = true;
_g.v["au"] = "audio/x-au";
_g.k["au"] = true;
_g.v["avi"] = "video/avi";
_g.k["avi"] = true;
_g.v["avs"] = "video/avs-video";
_g.k["avs"] = true;
_g.v["axs"] = "application/olescript";
_g.k["axs"] = true;
_g.v["bas"] = "text/plain";
_g.k["bas"] = true;
_g.v["bcpio"] = "application/x-bcpio";
_g.k["bcpio"] = true;
_g.v["bin"] = "application/octet-stream";
_g.k["bin"] = true;
_g.v["bm"] = "image/bmp";
_g.k["bm"] = true;
_g.v["bmp"] = "image/bmp";
_g.k["bmp"] = true;
_g.v["boo"] = "application/book";
_g.k["boo"] = true;
_g.v["book"] = "application/book";
_g.k["book"] = true;
_g.v["boz"] = "application/x-bzip2";
_g.k["boz"] = true;
_g.v["bsh"] = "application/x-bsh";
_g.k["bsh"] = true;
_g.v["bz2"] = "application/x-bzip2";
_g.k["bz2"] = true;
_g.v["bz"] = "application/x-bzip";
_g.k["bz"] = true;
_g.v["cat"] = "application/vnd.ms-pki.seccat";
_g.k["cat"] = true;
_g.v["ccad"] = "application/clariscad";
_g.k["ccad"] = true;
_g.v["cco"] = "application/x-cocoa";
_g.k["cco"] = true;
_g.v["cc"] = "text/plain";
_g.k["cc"] = true;
_g.v["cdf"] = "application/cdf";
_g.k["cdf"] = true;
_g.v["cer"] = "application/pkix-cert";
_g.k["cer"] = true;
_g.v["cha"] = "application/x-chat";
_g.k["cha"] = true;
_g.v["chat"] = "application/x-chat";
_g.k["chat"] = true;
_g.v["class"] = "application/x-java-applet";
_g.k["class"] = true;
_g.v["clp"] = "application/x-msclip";
_g.k["clp"] = true;
_g.v["cmx"] = "image/x-cmx";
_g.k["cmx"] = true;
_g.v["cod"] = "image/cis-cod";
_g.k["cod"] = true;
_g.v["coffee"] = "text/x-coffeescript";
_g.k["coffee"] = true;
_g.v["conf"] = "text/plain";
_g.k["conf"] = true;
_g.v["cpio"] = "application/x-cpio";
_g.k["cpio"] = true;
_g.v["cpp"] = "text/plain";
_g.k["cpp"] = true;
_g.v["cpt"] = "application/x-cpt";
_g.k["cpt"] = true;
_g.v["crd"] = "application/x-mscardfile";
_g.k["crd"] = true;
_g.v["crl"] = "application/pkix-crl";
_g.k["crl"] = true;
_g.v["crt"] = "application/pkix-cert";
_g.k["crt"] = true;
_g.v["csh"] = "application/x-csh";
_g.k["csh"] = true;
_g.v["css"] = "text/css";
_g.k["css"] = true;
_g.v["c"] = "text/plain";
_g.k["c"] = true;
_g.v["c++"] = "text/plain";
_g.k["c++"] = true;
_g.v["cxx"] = "text/plain";
_g.k["cxx"] = true;
_g.v["dart"] = "application/dart";
_g.k["dart"] = true;
_g.v["dcr"] = "application/x-director";
_g.k["dcr"] = true;
_g.v["deb"] = "application/x-deb";
_g.k["deb"] = true;
_g.v["deepv"] = "application/x-deepv";
_g.k["deepv"] = true;
_g.v["def"] = "text/plain";
_g.k["def"] = true;
_g.v["deploy"] = "application/octet-stream";
_g.k["deploy"] = true;
_g.v["der"] = "application/x-x509-ca-cert";
_g.k["der"] = true;
_g.v["dib"] = "image/bmp";
_g.k["dib"] = true;
_g.v["dif"] = "video/x-dv";
_g.k["dif"] = true;
_g.v["dir"] = "application/x-director";
_g.k["dir"] = true;
_g.v["disco"] = "text/xml";
_g.k["disco"] = true;
_g.v["dll"] = "application/x-msdownload";
_g.k["dll"] = true;
_g.v["dl"] = "video/dl";
_g.k["dl"] = true;
_g.v["doc"] = "application/msword";
_g.k["doc"] = true;
_g.v["docm"] = "application/vnd.ms-word.document.macroEnabled.12";
_g.k["docm"] = true;
_g.v["docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
_g.k["docx"] = true;
_g.v["dot"] = "application/msword";
_g.k["dot"] = true;
_g.v["dotm"] = "application/vnd.ms-word.template.macroEnabled.12";
_g.k["dotm"] = true;
_g.v["dotx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.template";
_g.k["dotx"] = true;
_g.v["dp"] = "application/commonground";
_g.k["dp"] = true;
_g.v["drw"] = "application/drafting";
_g.k["drw"] = true;
_g.v["dtd"] = "application/xml-dtd";
_g.k["dtd"] = true;
_g.v["dvi"] = "application/x-dvi";
_g.k["dvi"] = true;
_g.v["dv"] = "video/x-dv";
_g.k["dv"] = true;
_g.v["dwf"] = "drawing/x-dwf (old)";
_g.k["dwf"] = true;
_g.v["dwg"] = "application/acad";
_g.k["dwg"] = true;
_g.v["dxf"] = "application/dxf";
_g.k["dxf"] = true;
_g.v["dxr"] = "application/x-director";
_g.k["dxr"] = true;
_g.v["elc"] = "application/x-elc";
_g.k["elc"] = true;
_g.v["el"] = "text/x-script.elisp";
_g.k["el"] = true;
_g.v["eml"] = "message/rfc822";
_g.k["eml"] = true;
_g.v["eot"] = "application/vnd.bw-fontobject";
_g.k["eot"] = true;
_g.v["eps"] = "application/postscript";
_g.k["eps"] = true;
_g.v["es"] = "application/x-esrehber";
_g.k["es"] = true;
_g.v["etx"] = "text/x-setext";
_g.k["etx"] = true;
_g.v["evy"] = "application/envoy";
_g.k["evy"] = true;
_g.v["exe"] = "application/octet-stream";
_g.k["exe"] = true;
_g.v["f77"] = "text/plain";
_g.k["f77"] = true;
_g.v["f90"] = "text/plain";
_g.k["f90"] = true;
_g.v["fdf"] = "application/vnd.fdf";
_g.k["fdf"] = true;
_g.v["fif"] = "image/fif";
_g.k["fif"] = true;
_g.v["flac"] = "audio/x-flac";
_g.k["flac"] = true;
_g.v["fli"] = "video/fli";
_g.k["fli"] = true;
_g.v["flo"] = "image/florian";
_g.k["flo"] = true;
_g.v["flr"] = "x-world/x-vrml";
_g.k["flr"] = true;
_g.v["flx"] = "text/vnd.fmi.flexstor";
_g.k["flx"] = true;
_g.v["fmf"] = "video/x-atomic3d-feature";
_g.k["fmf"] = true;
_g.v["for"] = "text/plain";
_g.k["for"] = true;
_g.v["fpx"] = "image/vnd.fpx";
_g.k["fpx"] = true;
_g.v["frl"] = "application/freeloader";
_g.k["frl"] = true;
_g.v["f"] = "text/plain";
_g.k["f"] = true;
_g.v["funk"] = "audio/make";
_g.k["funk"] = true;
_g.v["g3"] = "image/g3fax";
_g.k["g3"] = true;
_g.v["gif"] = "image/gif";
_g.k["gif"] = true;
_g.v["gl"] = "video/gl";
_g.k["gl"] = true;
_g.v["gsd"] = "audio/x-gsm";
_g.k["gsd"] = true;
_g.v["gsm"] = "audio/x-gsm";
_g.k["gsm"] = true;
_g.v["gsp"] = "application/x-gsp";
_g.k["gsp"] = true;
_g.v["gss"] = "application/x-gss";
_g.k["gss"] = true;
_g.v["gtar"] = "application/x-gtar";
_g.k["gtar"] = true;
_g.v["g"] = "text/plain";
_g.k["g"] = true;
_g.v["gz"] = "application/x-gzip";
_g.k["gz"] = true;
_g.v["gzip"] = "application/x-gzip";
_g.k["gzip"] = true;
_g.v["hdf"] = "application/x-hdf";
_g.k["hdf"] = true;
_g.v["help"] = "application/x-helpfile";
_g.k["help"] = true;
_g.v["hgl"] = "application/vnd.hp-HPGL";
_g.k["hgl"] = true;
_g.v["hh"] = "text/plain";
_g.k["hh"] = true;
_g.v["hlb"] = "text/x-script";
_g.k["hlb"] = true;
_g.v["hlp"] = "application/x-helpfile";
_g.k["hlp"] = true;
_g.v["hpg"] = "application/vnd.hp-HPGL";
_g.k["hpg"] = true;
_g.v["hpgl"] = "application/vnd.hp-HPGL";
_g.k["hpgl"] = true;
_g.v["hqx"] = "application/binhex";
_g.k["hqx"] = true;
_g.v["hta"] = "application/hta";
_g.k["hta"] = true;
_g.v["htc"] = "text/x-component";
_g.k["htc"] = true;
_g.v["h"] = "text/plain";
_g.k["h"] = true;
_g.v["htmls"] = "text/html";
_g.k["htmls"] = true;
_g.v["html"] = "text/html";
_g.k["html"] = true;
_g.v["htm"] = "text/html";
_g.k["htm"] = true;
_g.v["htt"] = "text/webviewhtml";
_g.k["htt"] = true;
_g.v["htx"] = "text/html";
_g.k["htx"] = true;
_g.v["ice"] = "x-conference/x-cooltalk";
_g.k["ice"] = true;
_g.v["ico"] = "image/x-icon";
_g.k["ico"] = true;
_g.v["ics"] = "text/calendar";
_g.k["ics"] = true;
_g.v["idc"] = "text/plain";
_g.k["idc"] = true;
_g.v["ief"] = "image/ief";
_g.k["ief"] = true;
_g.v["iefs"] = "image/ief";
_g.k["iefs"] = true;
_g.v["iges"] = "application/iges";
_g.k["iges"] = true;
_g.v["igs"] = "application/iges";
_g.k["igs"] = true;
_g.v["iii"] = "application/x-iphone";
_g.k["iii"] = true;
_g.v["ima"] = "application/x-ima";
_g.k["ima"] = true;
_g.v["imap"] = "application/x-httpd-imap";
_g.k["imap"] = true;
_g.v["inf"] = "application/inf";
_g.k["inf"] = true;
_g.v["ins"] = "application/x-internett-signup";
_g.k["ins"] = true;
_g.v["ip"] = "application/x-ip2";
_g.k["ip"] = true;
_g.v["isp"] = "application/x-internet-signup";
_g.k["isp"] = true;
_g.v["isu"] = "video/x-isvideo";
_g.k["isu"] = true;
_g.v["it"] = "audio/it";
_g.k["it"] = true;
_g.v["iv"] = "application/x-inventor";
_g.k["iv"] = true;
_g.v["ivf"] = "video/x-ivf";
_g.k["ivf"] = true;
_g.v["ivr"] = "i-world/i-vrml";
_g.k["ivr"] = true;
_g.v["ivy"] = "application/x-livescreen";
_g.k["ivy"] = true;
_g.v["jam"] = "audio/x-jam";
_g.k["jam"] = true;
_g.v["jar"] = "application/java-archive";
_g.k["jar"] = true;
_g.v["java"] = "text/plain";
_g.k["java"] = true;
_g.v["jav"] = "text/plain";
_g.k["jav"] = true;
_g.v["jcm"] = "application/x-java-commerce";
_g.k["jcm"] = true;
_g.v["jfif"] = "image/jpeg";
_g.k["jfif"] = true;
_g.v["jfif-tbnl"] = "image/jpeg";
_g.k["jfif-tbnl"] = true;
_g.v["jpeg"] = "image/jpeg";
_g.k["jpeg"] = true;
_g.v["jpe"] = "image/jpeg";
_g.k["jpe"] = true;
_g.v["jpg"] = "image/jpeg";
_g.k["jpg"] = true;
_g.v["jps"] = "image/x-jps";
_g.k["jps"] = true;
_g.v["js"] = "application/javascript";
_g.k["js"] = true;
_g.v["json"] = "application/json";
_g.k["json"] = true;
_g.v["jut"] = "image/jutvision";
_g.k["jut"] = true;
_g.v["kar"] = "audio/midi";
_g.k["kar"] = true;
_g.v["ksh"] = "text/x-script.ksh";
_g.k["ksh"] = true;
_g.v["la"] = "audio/nspaudio";
_g.k["la"] = true;
_g.v["lam"] = "audio/x-liveaudio";
_g.k["lam"] = true;
_g.v["latex"] = "application/x-latex";
_g.k["latex"] = true;
_g.v["list"] = "text/plain";
_g.k["list"] = true;
_g.v["lma"] = "audio/nspaudio";
_g.k["lma"] = true;
_g.v["log"] = "text/plain";
_g.k["log"] = true;
_g.v["lsp"] = "application/x-lisp";
_g.k["lsp"] = true;
_g.v["lst"] = "text/plain";
_g.k["lst"] = true;
_g.v["lsx"] = "text/x-la-asf";
_g.k["lsx"] = true;
_g.v["ltx"] = "application/x-latex";
_g.k["ltx"] = true;
_g.v["m13"] = "application/x-msmediaview";
_g.k["m13"] = true;
_g.v["m14"] = "application/x-msmediaview";
_g.k["m14"] = true;
_g.v["m1v"] = "video/mpeg";
_g.k["m1v"] = true;
_g.v["m2a"] = "audio/mpeg";
_g.k["m2a"] = true;
_g.v["m2v"] = "video/mpeg";
_g.k["m2v"] = true;
_g.v["m3u"] = "audio/x-mpequrl";
_g.k["m3u"] = true;
_g.v["m4a"] = "audio/mp4";
_g.k["m4a"] = true;
_g.v["m4v"] = "video/mp4";
_g.k["m4v"] = true;
_g.v["man"] = "application/x-troff-man";
_g.k["man"] = true;
_g.v["manifest"] = "application/x-ms-manifest";
_g.k["manifest"] = true;
_g.v["map"] = "application/x-navimap";
_g.k["map"] = true;
_g.v["mar"] = "text/plain";
_g.k["mar"] = true;
_g.v["mbd"] = "application/mbedlet";
_g.k["mbd"] = true;
_g.v["mc$"] = "application/x-magic-cap-package-1.0";
_g.k["mc$"] = true;
_g.v["mcd"] = "application/mcad";
_g.k["mcd"] = true;
_g.v["mcf"] = "image/vasa";
_g.k["mcf"] = true;
_g.v["mcp"] = "application/netmc";
_g.k["mcp"] = true;
_g.v["mdb"] = "application/x-msaccess";
_g.k["mdb"] = true;
_g.v["mesh"] = "model/mesh";
_g.k["mesh"] = true;
_g.v["me"] = "application/x-troff-me";
_g.k["me"] = true;
_g.v["mid"] = "audio/midi";
_g.k["mid"] = true;
_g.v["midi"] = "audio/midi";
_g.k["midi"] = true;
_g.v["mif"] = "application/x-mif";
_g.k["mif"] = true;
_g.v["mjf"] = "audio/x-vnd.AudioExplosion.MjuiceMediaFile";
_g.k["mjf"] = true;
_g.v["mjpg"] = "video/x-motion-jpeg";
_g.k["mjpg"] = true;
_g.v["mm"] = "application/base64";
_g.k["mm"] = true;
_g.v["mme"] = "application/base64";
_g.k["mme"] = true;
_g.v["mny"] = "application/x-msmoney";
_g.k["mny"] = true;
_g.v["mod"] = "audio/mod";
_g.k["mod"] = true;
_g.v["mov"] = "video/quicktime";
_g.k["mov"] = true;
_g.v["movie"] = "video/x-sgi-movie";
_g.k["movie"] = true;
_g.v["mp2"] = "video/mpeg";
_g.k["mp2"] = true;
_g.v["mp3"] = "audio/mpeg";
_g.k["mp3"] = true;
_g.v["mp4"] = "video/mp4";
_g.k["mp4"] = true;
_g.v["mp4a"] = "audio/mp4";
_g.k["mp4a"] = true;
_g.v["mp4v"] = "video/mp4";
_g.k["mp4v"] = true;
_g.v["mpa"] = "audio/mpeg";
_g.k["mpa"] = true;
_g.v["mpc"] = "application/x-project";
_g.k["mpc"] = true;
_g.v["mpeg"] = "video/mpeg";
_g.k["mpeg"] = true;
_g.v["mpe"] = "video/mpeg";
_g.k["mpe"] = true;
_g.v["mpga"] = "audio/mpeg";
_g.k["mpga"] = true;
_g.v["mpg"] = "video/mpeg";
_g.k["mpg"] = true;
_g.v["mpp"] = "application/vnd.ms-project";
_g.k["mpp"] = true;
_g.v["mpt"] = "application/x-project";
_g.k["mpt"] = true;
_g.v["mpv2"] = "video/mpeg";
_g.k["mpv2"] = true;
_g.v["mpv"] = "application/x-project";
_g.k["mpv"] = true;
_g.v["mpx"] = "application/x-project";
_g.k["mpx"] = true;
_g.v["mrc"] = "application/marc";
_g.k["mrc"] = true;
_g.v["ms"] = "application/x-troff-ms";
_g.k["ms"] = true;
_g.v["msh"] = "model/mesh";
_g.k["msh"] = true;
_g.v["m"] = "text/plain";
_g.k["m"] = true;
_g.v["mvb"] = "application/x-msmediaview";
_g.k["mvb"] = true;
_g.v["mv"] = "video/x-sgi-movie";
_g.k["mv"] = true;
_g.v["my"] = "audio/make";
_g.k["my"] = true;
_g.v["mzz"] = "application/x-vnd.AudioExplosion.mzz";
_g.k["mzz"] = true;
_g.v["nap"] = "image/naplps";
_g.k["nap"] = true;
_g.v["naplps"] = "image/naplps";
_g.k["naplps"] = true;
_g.v["nc"] = "application/x-netcdf";
_g.k["nc"] = true;
_g.v["ncm"] = "application/vnd.nokia.configuration-message";
_g.k["ncm"] = true;
_g.v["niff"] = "image/x-niff";
_g.k["niff"] = true;
_g.v["nif"] = "image/x-niff";
_g.k["nif"] = true;
_g.v["nix"] = "application/x-mix-transfer";
_g.k["nix"] = true;
_g.v["nsc"] = "application/x-conference";
_g.k["nsc"] = true;
_g.v["nvd"] = "application/x-navidoc";
_g.k["nvd"] = true;
_g.v["nws"] = "message/rfc822";
_g.k["nws"] = true;
_g.v["oda"] = "application/oda";
_g.k["oda"] = true;
_g.v["ods"] = "application/oleobject";
_g.k["ods"] = true;
_g.v["oga"] = "audio/ogg";
_g.k["oga"] = true;
_g.v["ogg"] = "audio/ogg";
_g.k["ogg"] = true;
_g.v["ogv"] = "video/ogg";
_g.k["ogv"] = true;
_g.v["ogx"] = "application/ogg";
_g.k["ogx"] = true;
_g.v["omc"] = "application/x-omc";
_g.k["omc"] = true;
_g.v["omcd"] = "application/x-omcdatamaker";
_g.k["omcd"] = true;
_g.v["omcr"] = "application/x-omcregerator";
_g.k["omcr"] = true;
_g.v["opus"] = "audio/ogg";
_g.k["opus"] = true;
_g.v["oxps"] = "application/oxps";
_g.k["oxps"] = true;
_g.v["p10"] = "application/pkcs10";
_g.k["p10"] = true;
_g.v["p12"] = "application/pkcs-12";
_g.k["p12"] = true;
_g.v["p7a"] = "application/x-pkcs7-signature";
_g.k["p7a"] = true;
_g.v["p7b"] = "application/x-pkcs7-certificates";
_g.k["p7b"] = true;
_g.v["p7c"] = "application/pkcs7-mime";
_g.k["p7c"] = true;
_g.v["p7m"] = "application/pkcs7-mime";
_g.k["p7m"] = true;
_g.v["p7r"] = "application/x-pkcs7-certreqresp";
_g.k["p7r"] = true;
_g.v["p7s"] = "application/pkcs7-signature";
_g.k["p7s"] = true;
_g.v["part"] = "application/pro_eng";
_g.k["part"] = true;
_g.v["pas"] = "text/pascal";
_g.k["pas"] = true;
_g.v["pbm"] = "image/x-portable-bitmap";
_g.k["pbm"] = true;
_g.v["pcl"] = "application/x-pcl";
_g.k["pcl"] = true;
_g.v["pct"] = "image/x-pict";
_g.k["pct"] = true;
_g.v["pcx"] = "image/x-pcx";
_g.k["pcx"] = true;
_g.v["pdb"] = "chemical/x-pdb";
_g.k["pdb"] = true;
_g.v["pdf"] = "application/pdf";
_g.k["pdf"] = true;
_g.v["pfunk"] = "audio/make";
_g.k["pfunk"] = true;
_g.v["pfx"] = "application/x-pkcs12";
_g.k["pfx"] = true;
_g.v["pgm"] = "image/x-portable-graymap";
_g.k["pgm"] = true;
_g.v["pic"] = "image/pict";
_g.k["pic"] = true;
_g.v["pict"] = "image/pict";
_g.k["pict"] = true;
_g.v["pkg"] = "application/x-newton-compatible-pkg";
_g.k["pkg"] = true;
_g.v["pko"] = "application/vnd.ms-pki.pko";
_g.k["pko"] = true;
_g.v["pl"] = "text/plain";
_g.k["pl"] = true;
_g.v["plx"] = "application/x-PiXCLscript";
_g.k["plx"] = true;
_g.v["pm4"] = "application/x-pagemaker";
_g.k["pm4"] = true;
_g.v["pm5"] = "application/x-pagemaker";
_g.k["pm5"] = true;
_g.v["pma"] = "application/x-perfmon";
_g.k["pma"] = true;
_g.v["pmc"] = "application/x-perfmon";
_g.k["pmc"] = true;
_g.v["pm"] = "image/x-xpixmap";
_g.k["pm"] = true;
_g.v["pml"] = "application/x-perfmon";
_g.k["pml"] = true;
_g.v["pmr"] = "application/x-perfmon";
_g.k["pmr"] = true;
_g.v["pmw"] = "application/x-perfmon";
_g.k["pmw"] = true;
_g.v["png"] = "image/png";
_g.k["png"] = true;
_g.v["pnm"] = "application/x-portable-anymap";
_g.k["pnm"] = true;
_g.v["pot"] = "application/vnd.ms-powerpoint";
_g.k["pot"] = true;
_g.v["potm"] = "application/vnd.ms-powerpoint.template.macroEnabled.12";
_g.k["potm"] = true;
_g.v["potx"] = "application/vnd.openxmlformats-officedocument.presentationml.template";
_g.k["potx"] = true;
_g.v["pov"] = "model/x-pov";
_g.k["pov"] = true;
_g.v["ppa"] = "application/vnd.ms-powerpoint";
_g.k["ppa"] = true;
_g.v["ppam"] = "application/vnd.ms-powerpoint.setin.macroEnabled.12";
_g.k["ppam"] = true;
_g.v["ppm"] = "image/x-portable-pixmap";
_g.k["ppm"] = true;
_g.v["pps"] = "application/vnd.ms-powerpoint";
_g.k["pps"] = true;
_g.v["ppsm"] = "application/vnd.ms-powerpoint.slideshow.macroEnabled.12";
_g.k["ppsm"] = true;
_g.v["ppsx"] = "application/vnd.openxmlformats-officedocument.presentationml.slideshow";
_g.k["ppsx"] = true;
_g.v["ppt"] = "application/vnd.ms-powerpoint";
_g.k["ppt"] = true;
_g.v["pptm"] = "application/vnd.ms-powerpoint.presentation.macroEnabled.12";
_g.k["pptm"] = true;
_g.v["pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
_g.k["pptx"] = true;
_g.v["ppz"] = "application/mspowerpoint";
_g.k["ppz"] = true;
_g.v["pre"] = "application/x-freelance";
_g.k["pre"] = true;
_g.v["prf"] = "application/pics-rules";
_g.k["prf"] = true;
_g.v["prt"] = "application/pro_eng";
_g.k["prt"] = true;
_g.v["ps"] = "application/postscript";
_g.k["ps"] = true;
_g.v["p"] = "text/x-pascal";
_g.k["p"] = true;
_g.v["pub"] = "application/x-mspublisher";
_g.k["pub"] = true;
_g.v["pvu"] = "paleovu/x-pv";
_g.k["pvu"] = true;
_g.v["pwz"] = "application/vnd.ms-powerpoint";
_g.k["pwz"] = true;
_g.v["pyc"] = "applicaiton/x-bytecode.python";
_g.k["pyc"] = true;
_g.v["py"] = "text/x-script.phyton";
_g.k["py"] = true;
_g.v["qcp"] = "audio/vnd.qcelp";
_g.k["qcp"] = true;
_g.v["qd3d"] = "x-world/x-3dmf";
_g.k["qd3d"] = true;
_g.v["qd3"] = "x-world/x-3dmf";
_g.k["qd3"] = true;
_g.v["qif"] = "image/x-quicktime";
_g.k["qif"] = true;
_g.v["qtc"] = "video/x-qtc";
_g.k["qtc"] = true;
_g.v["qtif"] = "image/x-quicktime";
_g.k["qtif"] = true;
_g.v["qti"] = "image/x-quicktime";
_g.k["qti"] = true;
_g.v["qt"] = "video/quicktime";
_g.k["qt"] = true;
_g.v["ra"] = "audio/x-pn-realaudio";
_g.k["ra"] = true;
_g.v["ram"] = "audio/x-pn-realaudio";
_g.k["ram"] = true;
_g.v["ras"] = "application/x-cmu-raster";
_g.k["ras"] = true;
_g.v["rast"] = "image/cmu-raster";
_g.k["rast"] = true;
_g.v["rexx"] = "text/x-script.rexx";
_g.k["rexx"] = true;
_g.v["rf"] = "image/vnd.rn-realflash";
_g.k["rf"] = true;
_g.v["rgb"] = "image/x-rgb";
_g.k["rgb"] = true;
_g.v["rm"] = "application/vnd.rn-realmedia";
_g.k["rm"] = true;
_g.v["rmi"] = "audio/mid";
_g.k["rmi"] = true;
_g.v["rmm"] = "audio/x-pn-realaudio";
_g.k["rmm"] = true;
_g.v["rmp"] = "audio/x-pn-realaudio";
_g.k["rmp"] = true;
_g.v["rng"] = "application/ringing-tones";
_g.k["rng"] = true;
_g.v["rnx"] = "application/vnd.rn-realplayer";
_g.k["rnx"] = true;
_g.v["roff"] = "application/x-troff";
_g.k["roff"] = true;
_g.v["rp"] = "image/vnd.rn-realpix";
_g.k["rp"] = true;
_g.v["rpm"] = "audio/x-pn-realaudio-plugin";
_g.k["rpm"] = true;
_g.v["rss"] = "application/rss+xml";
_g.k["rss"] = true;
_g.v["rtf"] = "text/richtext";
_g.k["rtf"] = true;
_g.v["rt"] = "text/richtext";
_g.k["rt"] = true;
_g.v["rtx"] = "text/richtext";
_g.k["rtx"] = true;
_g.v["rv"] = "video/vnd.rn-realvideo";
_g.k["rv"] = true;
_g.v["s3m"] = "audio/s3m";
_g.k["s3m"] = true;
_g.v["sbk"] = "application/x-tbook";
_g.k["sbk"] = true;
_g.v["scd"] = "application/x-msschedule";
_g.k["scd"] = true;
_g.v["scm"] = "application/x-lotusscreencam";
_g.k["scm"] = true;
_g.v["sct"] = "text/scriptlet";
_g.k["sct"] = true;
_g.v["sdml"] = "text/plain";
_g.k["sdml"] = true;
_g.v["sdp"] = "application/sdp";
_g.k["sdp"] = true;
_g.v["sdr"] = "application/sounder";
_g.k["sdr"] = true;
_g.v["sea"] = "application/sea";
_g.k["sea"] = true;
_g.v["set"] = "application/set";
_g.k["set"] = true;
_g.v["setpay"] = "application/set-payment-initiation";
_g.k["setpay"] = true;
_g.v["setreg"] = "application/set-registration-initiation";
_g.k["setreg"] = true;
_g.v["sgml"] = "text/sgml";
_g.k["sgml"] = true;
_g.v["sgm"] = "text/sgml";
_g.k["sgm"] = true;
_g.v["shar"] = "application/x-bsh";
_g.k["shar"] = true;
_g.v["sh"] = "text/x-script.sh";
_g.k["sh"] = true;
_g.v["shtml"] = "text/html";
_g.k["shtml"] = true;
_g.v["sid"] = "audio/x-psid";
_g.k["sid"] = true;
_g.v["silo"] = "model/mesh";
_g.k["silo"] = true;
_g.v["sit"] = "application/x-sit";
_g.k["sit"] = true;
_g.v["skd"] = "application/x-koan";
_g.k["skd"] = true;
_g.v["skm"] = "application/x-koan";
_g.k["skm"] = true;
_g.v["skp"] = "application/x-koan";
_g.k["skp"] = true;
_g.v["skt"] = "application/x-koan";
_g.k["skt"] = true;
_g.v["sl"] = "application/x-seelogo";
_g.k["sl"] = true;
_g.v["smi"] = "application/smil";
_g.k["smi"] = true;
_g.v["smil"] = "application/smil";
_g.k["smil"] = true;
_g.v["snd"] = "audio/basic";
_g.k["snd"] = true;
_g.v["sol"] = "application/solids";
_g.k["sol"] = true;
_g.v["spc"] = "application/x-pkcs7-certificates";
_g.k["spc"] = true;
_g.v["spl"] = "application/futuresplash";
_g.k["spl"] = true;
_g.v["spr"] = "application/x-sprite";
_g.k["spr"] = true;
_g.v["sprite"] = "application/x-sprite";
_g.k["sprite"] = true;
_g.v["spx"] = "audio/ogg";
_g.k["spx"] = true;
_g.v["src"] = "application/x-wais-source";
_g.k["src"] = true;
_g.v["ssi"] = "text/x-server-parsed-html";
_g.k["ssi"] = true;
_g.v["ssm"] = "application/streamingmedia";
_g.k["ssm"] = true;
_g.v["sst"] = "application/vnd.ms-pki.certstore";
_g.k["sst"] = true;
_g.v["step"] = "application/step";
_g.k["step"] = true;
_g.v["s"] = "text/x-asm";
_g.k["s"] = true;
_g.v["stl"] = "application/sla";
_g.k["stl"] = true;
_g.v["stm"] = "text/html";
_g.k["stm"] = true;
_g.v["stp"] = "application/step";
_g.k["stp"] = true;
_g.v["sv4cpio"] = "application/x-sv4cpio";
_g.k["sv4cpio"] = true;
_g.v["sv4crc"] = "application/x-sv4crc";
_g.k["sv4crc"] = true;
_g.v["svf"] = "image/x-dwg";
_g.k["svf"] = true;
_g.v["svg"] = "image/svg+xml";
_g.k["svg"] = true;
_g.v["svr"] = "application/x-world";
_g.k["svr"] = true;
_g.v["swf"] = "application/x-shockwave-flash";
_g.k["swf"] = true;
_g.v["talk"] = "text/x-speech";
_g.k["talk"] = true;
_g.v["t"] = "application/x-troff";
_g.k["t"] = true;
_g.v["tar"] = "application/x-tar";
_g.k["tar"] = true;
_g.v["tbk"] = "application/toolbook";
_g.k["tbk"] = true;
_g.v["tcl"] = "text/x-script.tcl";
_g.k["tcl"] = true;
_g.v["tcsh"] = "text/x-script.tcsh";
_g.k["tcsh"] = true;
_g.v["tex"] = "application/x-tex";
_g.k["tex"] = true;
_g.v["texi"] = "application/x-texinfo";
_g.k["texi"] = true;
_g.v["texinfo"] = "application/x-texinfo";
_g.k["texinfo"] = true;
_g.v["text"] = "text/plain";
_g.k["text"] = true;
_g.v["tgz"] = "application/x-compressed";
_g.k["tgz"] = true;
_g.v["tiff"] = "image/tiff";
_g.k["tiff"] = true;
_g.v["tif"] = "image/tiff";
_g.k["tif"] = true;
_g.v["tr"] = "application/x-troff";
_g.k["tr"] = true;
_g.v["trm"] = "application/x-msterminal";
_g.k["trm"] = true;
_g.v["ts"] = "text/x-typescript";
_g.k["ts"] = true;
_g.v["tsi"] = "audio/tsp-audio";
_g.k["tsi"] = true;
_g.v["tsp"] = "audio/tsplayer";
_g.k["tsp"] = true;
_g.v["tsv"] = "text/tab-separated-values";
_g.k["tsv"] = true;
_g.v["ttf"] = "application/x-font-ttf";
_g.k["ttf"] = true;
_g.v["turbot"] = "image/florian";
_g.k["turbot"] = true;
_g.v["txt"] = "text/plain";
_g.k["txt"] = true;
_g.v["uil"] = "text/x-uil";
_g.k["uil"] = true;
_g.v["uls"] = "text/iuls";
_g.k["uls"] = true;
_g.v["unis"] = "text/uri-list";
_g.k["unis"] = true;
_g.v["uni"] = "text/uri-list";
_g.k["uni"] = true;
_g.v["unv"] = "application/i-deas";
_g.k["unv"] = true;
_g.v["uris"] = "text/uri-list";
_g.k["uris"] = true;
_g.v["uri"] = "text/uri-list";
_g.k["uri"] = true;
_g.v["ustar"] = "multipart/x-ustar";
_g.k["ustar"] = true;
_g.v["uue"] = "text/x-uuencode";
_g.k["uue"] = true;
_g.v["uu"] = "text/x-uuencode";
_g.k["uu"] = true;
_g.v["vcd"] = "application/x-cdlink";
_g.k["vcd"] = true;
_g.v["vcf"] = "text/vcard";
_g.k["vcf"] = true;
_g.v["vcard"] = "text/vcard";
_g.k["vcard"] = true;
_g.v["vcs"] = "text/x-vCalendar";
_g.k["vcs"] = true;
_g.v["vda"] = "application/vda";
_g.k["vda"] = true;
_g.v["vdo"] = "video/vdo";
_g.k["vdo"] = true;
_g.v["vew"] = "application/groupwise";
_g.k["vew"] = true;
_g.v["vivo"] = "video/vivo";
_g.k["vivo"] = true;
_g.v["viv"] = "video/vivo";
_g.k["viv"] = true;
_g.v["vmd"] = "application/vocaltec-media-desc";
_g.k["vmd"] = true;
_g.v["vmf"] = "application/vocaltec-media-file";
_g.k["vmf"] = true;
_g.v["voc"] = "audio/voc";
_g.k["voc"] = true;
_g.v["vos"] = "video/vosaic";
_g.k["vos"] = true;
_g.v["vox"] = "audio/voxware";
_g.k["vox"] = true;
_g.v["vqe"] = "audio/x-twinvq-plugin";
_g.k["vqe"] = true;
_g.v["vqf"] = "audio/x-twinvq";
_g.k["vqf"] = true;
_g.v["vql"] = "audio/x-twinvq-plugin";
_g.k["vql"] = true;
_g.v["vrml"] = "application/x-vrml";
_g.k["vrml"] = true;
_g.v["vrt"] = "x-world/x-vrt";
_g.k["vrt"] = true;
_g.v["vsd"] = "application/x-visio";
_g.k["vsd"] = true;
_g.v["vst"] = "application/x-visio";
_g.k["vst"] = true;
_g.v["vsw"] = "application/x-visio";
_g.k["vsw"] = true;
_g.v["w60"] = "application/wordperfect6.0";
_g.k["w60"] = true;
_g.v["w61"] = "application/wordperfect6.1";
_g.k["w61"] = true;
_g.v["w6w"] = "application/msword";
_g.k["w6w"] = true;
_g.v["wav"] = "audio/wav";
_g.k["wav"] = true;
_g.v["wb1"] = "application/x-qpro";
_g.k["wb1"] = true;
_g.v["wbmp"] = "image/vnd.wap.wbmp";
_g.k["wbmp"] = true;
_g.v["wcm"] = "application/vnd.ms-works";
_g.k["wcm"] = true;
_g.v["wdb"] = "application/vnd.ms-works";
_g.k["wdb"] = true;
_g.v["web"] = "application/vnd.xara";
_g.k["web"] = true;
_g.v["webm"] = "video/webm";
_g.k["webm"] = true;
_g.v["wiz"] = "application/msword";
_g.k["wiz"] = true;
_g.v["wk1"] = "application/x-123";
_g.k["wk1"] = true;
_g.v["wks"] = "application/vnd.ms-works";
_g.k["wks"] = true;
_g.v["wmf"] = "windows/metafile";
_g.k["wmf"] = true;
_g.v["wmlc"] = "application/vnd.wap.wmlc";
_g.k["wmlc"] = true;
_g.v["wmlsc"] = "application/vnd.wap.wmlscriptc";
_g.k["wmlsc"] = true;
_g.v["wmls"] = "text/vnd.wap.wmlscript";
_g.k["wmls"] = true;
_g.v["wml"] = "text/vnd.wap.wml";
_g.k["wml"] = true;
_g.v["wmp"] = "video/x-ms-wmp";
_g.k["wmp"] = true;
_g.v["wmv"] = "video/x-ms-wmv";
_g.k["wmv"] = true;
_g.v["wmx"] = "video/x-ms-wmx";
_g.k["wmx"] = true;
_g.v["woff"] = "application/x-woff";
_g.k["woff"] = true;
_g.v["word"] = "application/msword";
_g.k["word"] = true;
_g.v["wp5"] = "application/wordperfect";
_g.k["wp5"] = true;
_g.v["wp6"] = "application/wordperfect";
_g.k["wp6"] = true;
_g.v["wp"] = "application/wordperfect";
_g.k["wp"] = true;
_g.v["wpd"] = "application/wordperfect";
_g.k["wpd"] = true;
_g.v["wps"] = "application/vnd.ms-works";
_g.k["wps"] = true;
_g.v["wq1"] = "application/x-lotus";
_g.k["wq1"] = true;
_g.v["wri"] = "application/mswrite";
_g.k["wri"] = true;
_g.v["wrl"] = "application/x-world";
_g.k["wrl"] = true;
_g.v["wrz"] = "model/vrml";
_g.k["wrz"] = true;
_g.v["wsc"] = "text/scriplet";
_g.k["wsc"] = true;
_g.v["wsdl"] = "text/xml";
_g.k["wsdl"] = true;
_g.v["wsrc"] = "application/x-wais-source";
_g.k["wsrc"] = true;
_g.v["wtk"] = "application/x-wintalk";
_g.k["wtk"] = true;
_g.v["wvx"] = "video/x-ms-wvx";
_g.k["wvx"] = true;
_g.v["x3d"] = "model/x3d+xml";
_g.k["x3d"] = true;
_g.v["x3db"] = "model/x3d+fastinfoset";
_g.k["x3db"] = true;
_g.v["x3dv"] = "model/x3d-vrml";
_g.k["x3dv"] = true;
_g.v["xaf"] = "x-world/x-vrml";
_g.k["xaf"] = true;
_g.v["xaml"] = "application/xaml+xml";
_g.k["xaml"] = true;
_g.v["xap"] = "application/x-silverlight-app";
_g.k["xap"] = true;
_g.v["xbap"] = "application/x-ms-xbap";
_g.k["xbap"] = true;
_g.v["xbm"] = "image/x-xbitmap";
_g.k["xbm"] = true;
_g.v["xdr"] = "video/x-amt-demorun";
_g.k["xdr"] = true;
_g.v["xgz"] = "xgl/drawing";
_g.k["xgz"] = true;
_g.v["xht"] = "application/xhtml+xml";
_g.k["xht"] = true;
_g.v["xhtml"] = "application/xhtml+xml";
_g.k["xhtml"] = true;
_g.v["xif"] = "image/vnd.xiff";
_g.k["xif"] = true;
_g.v["xla"] = "application/vnd.ms-excel";
_g.k["xla"] = true;
_g.v["xlam"] = "application/vnd.ms-excel.setin.macroEnabled.12";
_g.k["xlam"] = true;
_g.v["xl"] = "application/excel";
_g.k["xl"] = true;
_g.v["xlb"] = "application/excel";
_g.k["xlb"] = true;
_g.v["xlc"] = "application/excel";
_g.k["xlc"] = true;
_g.v["xld"] = "application/excel";
_g.k["xld"] = true;
_g.v["xlk"] = "application/excel";
_g.k["xlk"] = true;
_g.v["xll"] = "application/excel";
_g.k["xll"] = true;
_g.v["xlm"] = "application/excel";
_g.k["xlm"] = true;
_g.v["xls"] = "application/vnd.ms-excel";
_g.k["xls"] = true;
_g.v["xlsb"] = "application/vnd.ms-excel.sheet.binary.macroEnabled.12";
_g.k["xlsb"] = true;
_g.v["xlsm"] = "application/vnd.ms-excel.sheet.macroEnabled.12";
_g.k["xlsm"] = true;
_g.v["xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
_g.k["xlsx"] = true;
_g.v["xlt"] = "application/vnd.ms-excel";
_g.k["xlt"] = true;
_g.v["xltm"] = "application/vnd.ms-excel.template.macroEnabled.12";
_g.k["xltm"] = true;
_g.v["xltx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.template";
_g.k["xltx"] = true;
_g.v["xlv"] = "application/excel";
_g.k["xlv"] = true;
_g.v["xlw"] = "application/excel";
_g.k["xlw"] = true;
_g.v["xm"] = "audio/xm";
_g.k["xm"] = true;
_g.v["xml"] = "text/xml";
_g.k["xml"] = true;
_g.v["xmz"] = "xgl/movie";
_g.k["xmz"] = true;
_g.v["xof"] = "x-world/x-vrml";
_g.k["xof"] = true;
_g.v["xpi"] = "application/x-xpinstall";
_g.k["xpi"] = true;
_g.v["xpix"] = "application/x-vnd.ls-xpix";
_g.k["xpix"] = true;
_g.v["xpm"] = "image/xpm";
_g.k["xpm"] = true;
_g.v["xps"] = "application/vnd.ms-xpsdocument";
_g.k["xps"] = true;
_g.v["x-png"] = "image/png";
_g.k["x-png"] = true;
_g.v["xsd"] = "text/xml";
_g.k["xsd"] = true;
_g.v["xsl"] = "text/xml";
_g.k["xsl"] = true;
_g.v["xslt"] = "text/xml";
_g.k["xslt"] = true;
_g.v["xsr"] = "video/x-amt-showrun";
_g.k["xsr"] = true;
_g.v["xwd"] = "image/x-xwd";
_g.k["xwd"] = true;
_g.v["xyz"] = "chemical/x-pdb";
_g.k["xyz"] = true;
_g.v["z"] = "application/x-compressed";
_g.k["z"] = true;
_g.v["zip"] = "application/zip";
_g.k["zip"] = true;
_g.v["zsh"] = "text/x-script.zsh";
_g.k["zsh"] = true;
mime.MimeTypes.mimeTypes = _g;
end
_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else 
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end
_hx_funcToField = function(f)
  if type(f) == 'function' then 
    return function(self,...) 
      return f(...) 
    end
  else 
    return f
  end
end
_hx_print = print or (function() end)
_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

  Server.main();
  haxe.EntryPoint.run();

return _hx_exports
